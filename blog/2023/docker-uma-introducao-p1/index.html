<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>docker - uma introdução didática - parte 1 | pfransozi.github.io</title> <meta name="author" content="Philipe Fransozi"> <meta name="description" content="introdução à conteinerização com docker e docker-compose, conceitos básicos, comandos e exemplos"> <meta property="og:site_name" content="pfransozi.github.io"> <meta property="og:type" content="website"> <meta property="og:title" content="pfransozi.github.io | docker - uma introdução didática - parte 1"> <meta property="og:url" content="https://pfransozi.github.io/blog/2023/docker-uma-introducao-p1/"> <meta property="og:description" content="introdução à conteinerização com docker e docker-compose, conceitos básicos, comandos e exemplos"> <meta property="og:locale" content="en"> <meta name="twitter:card" content="summary"> <meta name="twitter:title" content="docker - uma introdução didática - parte 1"> <meta name="twitter:description" content="introdução à conteinerização com docker e docker-compose, conceitos básicos, comandos e exemplos"> <script type="application/ld+json">
      {
        "author":
        {
          "@type": "Person",
          "name": "Philipe  Fransozi"
        },
        "url": "https://pfransozi.github.io/blog/2023/docker-uma-introducao-p1/",
        "@type": "WebSite",
        "description": "introdução à conteinerização com docker e docker-compose, conceitos básicos, comandos e exemplos",
        "headline": "docker - uma introdução didática - parte 1",
        "sameAs": ["https://tryhackme.com/p/OutroHomemComum", "https://github.com/pfransozi", "https://www.linkedin.com/in/philipehf"],
        "name": "Philipe  Fransozi",
        "@context": "https://schema.org"
      }
    </script> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/favicon.ico"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://pfransozi.github.io/blog/2023/docker-uma-introducao-p1/"> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/">pfransozi.github.io</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories</a> </li> <li class="nav-item "> <a class="nav-link" href="/links/">links</a> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">docker - uma introdução didática - parte 1</h1> <p class="post-meta">March 5, 2023</p> <p class="post-tags"> <a href="/blog/2023"> <i class="fas fa-calendar fa-sm"></i> 2023 </a>   ·   <a href="/blog/tag/docker"> <i class="fas fa-hashtag fa-sm"></i> docker</a>   <a href="/blog/tag/containerization"> <i class="fas fa-hashtag fa-sm"></i> containerization</a>   </p> </header> <article class="post-content"> <h2 id="introdução">Introdução</h2> <p>Este material traz um compilado de tópicos introdutórios sobre as ferramentas desenvolvidas pela <em>docker inc</em>: <code class="language-plaintext highlighter-rouge">docker</code> e <code class="language-plaintext highlighter-rouge">docker-compose</code>; com teoria e prática. Elas surgiram e se popularizaram como um conjunto de ferramentas para conteinerização, embora o conceito de contêiner e algumas técnicas já existissem antes.</p> <p>Este material se estrutura em três partes e para compô-lo utilizei materiais que estão na seção referências.</p> <ul> <li> <a href="#primeira-parte">Primeira Parte</a> <ul> <li> <a href="#conceitos-bases">Conceitos bases</a>;</li> <li> <a href="#contexto">Contexto</a>;</li> <li> <a href="#instala%C3%A7%C3%A3o">Instalação</a>;</li> <li> <a href="#primeira-execu%C3%A7%C3%A3o">Primeira execução</a>;</li> <li> <a href="#imagem-e-cont%C3%AAiner">Imagem e contêiner</a>;</li> <li> <a href="#b%C3%A1sico-sobre-cliente-docker-linha-de-comando">Básico sobre cliente docker, linha de comando</a>;</li> <li> <a href="#executar-e-encerrar-cont%C3%AAineres">Executar e encerrar contêineres</a>;</li> <li> <a href="#mergulhando-nas-imagens">Mergulhando nas imagens</a>;</li> <li> <a href="#construindo-imagens">Construindo imagens</a>;</li> <li> <a href="#definindo-condi%C3%A7%C3%B5es-iniciais-do-cont%C3%AAiner">Definindo condições iniciais do contêiner</a>;</li> <li> <a href="#usando-volume-e-portas-para-interagir-com-cont%C3%AAineres">Usando volume e portas para interagir com contêineres</a>;</li> <li> <a href="#permitindo-conex%C3%B5es-externas-com-cont%C3%AAineres">Permitindo conexões externas com contêineres</a>;</li> <li> <a href="#exerc%C3%ADcios">Exercícios</a>;</li> <li> <a href="#refer%C3%AAncias">Referências</a>;</li> </ul> </li> <li><del>Segunda Parte</del></li> <li><del>Terceira Parte</del></li> </ul> <h2 id="primeira-parte">Primeira Parte</h2> <h3 id="conceitos-bases">Conceitos bases</h3> <p>Contêiner é uma tecnologia de virtualização do tipo de isolamento em nível de sistema operacional (<em>os-level virtualization</em>), diferenciando-se das virtualizações do tipo <em>hipervisionadas</em> (<em>hardware hypervisors</em>), cuja interação com o hardware é intermediada por meio de um software de supervisão. O isolamento de um contêiner ocorre no nível do sistema operacional por meio de técnicas de segregação de instâncias de espaços de usuários.</p> <p><em>Chroot</em> é uma das primeiras técnicas, se não a primeira, de isolamento em nível de sistema operacional pela qual processos e seus subprocessos são isolados do resto do sistema de arquivos e processos. Essa técnica consiste em recriar toda a árvore de diretórios necessárias para executar um programa, copiando todos os programas do sistema necessários para executá-lo e ajustando as referências para esse novo simulacro. Em seguida, é utilizado o <code class="language-plaintext highlighter-rouge">chroot</code> para modificar o diretório <code class="language-plaintext highlighter-rouge">root</code> para o diretório base recriado, criando um isolamento para o programa executado que não conseguirá acessar nada além do diretório base.</p> <p>Embora a técnica de <em>chroot</em> traga a ideia de isolamento em nível de sistema operacional, a técnica é muito limitada porque não faz isolamento no nível do espaço do kernel, mantendo todos os recursos de hardware compartilhados. As tecnologias mais modernas de contêineres utilizam técnica de isolamento em nível de sistema operacional que é implementada no nível do espaço do kernel, permitindo um isolamento total dos recursos de hardware. Dentre as vantagens desse tipo de técnica estão: redução das despesas (overhead) de recursos necessários para executar um recurso, principalmente se comparado à virtualização hipersivionada, pois os programas que rodam dentro de uma partição virtual usam as interfaces de chamadas de sistema padrões do sistema operacional.</p> <p>Com isso, <em>docker</em> é um conjunto de ferramentas cujo objetivo é implementar virtualização de nível do sistema operacional, com isolamento e mecanismos de gerenciamento de recursos, utilizando <code class="language-plaintext highlighter-rouge">cgroups</code> e <code class="language-plaintext highlighter-rouge">namespaces</code>. A base desse conjunto de ferramentas é uma estrutura cliente-servidor: servidor (<code class="language-plaintext highlighter-rouge">docker daemon</code>), comunicação por <code class="language-plaintext highlighter-rouge">rest api</code> (<code class="language-plaintext highlighter-rouge">docker engine</code> <code class="language-plaintext highlighter-rouge">api</code>), cliente (<code class="language-plaintext highlighter-rouge">docker cli</code>, <code class="language-plaintext highlighter-rouge">docker desktop</code>), repositório de imagens (<code class="language-plaintext highlighter-rouge">docker hub</code>). O serviço de <code class="language-plaintext highlighter-rouge">daemon</code> do <em>docker</em>, também chamado de <code class="language-plaintext highlighter-rouge">dockerd</code>, é um processo persistente que gerencia os contêineres e manipula objetos vinculados a eles. O <code class="language-plaintext highlighter-rouge">daemon</code> responde a requisições que chegam pela <code class="language-plaintext highlighter-rouge">api</code> e que se originam geralmente pela ferramenta de linha de comando.</p> <p><a href="#introdu%C3%A7%C3%A3o">⇡</a></p> <h3 id="contexto">Contexto</h3> <p><code class="language-plaintext highlighter-rouge">Docker</code> é uma consolidada ferramenta quando se pensa em integração e entrega contínuas em ambientes de desenvolvimento de software, pois:</p> <ul> <li>possibilita isolamento e customização de ambientes, ou seja, no contêiner é instalado apenas o que é necessário para a execução do software principal ou de algum servidor que dará suporte ao software principal;</li> <li>o isolamento de contêineres possibilita com que em um mesmo <em>host</em> vários contêineres executem diferentes versões de uma linguagem de programação, por exemplo, sem nenhuma interferência entre os próprios contêineres e entres eles e o <em>host</em>;</li> <li>possibilita criação de ambientes predefinidos que servem de base para a criação de outros contêineres mantendo integridade entre eles. Além disso, suporta infraestrutura como código (<em>IaC</em>), <code class="language-plaintext highlighter-rouge">dockerfile</code>, no qual se especificam várias características para uma imagem que servirá de protótipo para criação de contêineres;</li> <li>em relação a uma máquina virtual as despesa (overhead) de recursos necessários para o funcionamento de um contêiner são reduzidas. Nesse sentido, os contêineres são efêmeros porque deve ser possível criálos e destruí-los constantemente e sempre que necessário. Aumentar ou diminuir o número de instâncias de um contêiner é conhecido como escalonamento, tendo como objetivo aumentar ou diminuir recursos (<em>horizontal scaling</em>), que por sua vez visa aumentar ou diminuir a disponibilidade de um serviço;</li> <li>o caráter efêmero de um contêiner deve ser compreendido de modo pragmático, ou seja, <em>posso destruir todos eles hoje, mas também se for preciso recriá-los amanhã</em>;</li> </ul> <p><a href="#introdu%C3%A7%C3%A3o">⇡</a></p> <h3 id="instalação">Instalação</h3> <p>Dois são os pré-requisitos de instalação: <code class="language-plaintext highlighter-rouge">docker</code> e <code class="language-plaintext highlighter-rouge">docker-compose</code>, ambos da <em>docker inc.</em>. <em>Docker</em> possui um rico ambiente de documentação que pode ser acessado <a href="docs.docker.com" target="_blank">aqui</a>. Em se tratando de instalação, mais informações podem ser obtidas <a href="docs.docker.com/engine/install/" target="_blank">aqui</a>. O mesmo vale para <a href="docs.docker.com/compose/" target="_blank">docker-compose</a> e os documentos de <a href="https://docs.docker.com/compose/install/" target="_blank" rel="external nofollow noopener">instalação</a> para ele.</p> <p>Em se tratando da instalação do <code class="language-plaintext highlighter-rouge">docker</code> é importante saber que a arquitetura inicial exigia que ela fosse feita como super usuário (root / administrador). A partir da versão 19.03 essa exigência foi alterada, permitindo a instalação com usuário sem privilégios de root / administrador. Tal assunto pode ser visto <a href="https://docs.docker.com/engine/security/rootless/" target="_blank" rel="external nofollow noopener">aqui</a>.</p> <p>Além disso, é comum que após a instalação do <code class="language-plaintext highlighter-rouge">docker</code>, no caso em que se opte por executá-lo como super usuário, o usuário responsável por executá-lo seja incluído no grupo <code class="language-plaintext highlighter-rouge">docker</code>. Assim, não será necessário prefaciar o comando <code class="language-plaintext highlighter-rouge">docker</code> com <code class="language-plaintext highlighter-rouge">sudo</code>. Mais detalhes <a href="https://docs.docker.com/engine/install/linux-postinstall/" target="_blank" rel="external nofollow noopener">aqui</a>.</p> <p><a href="#introdu%C3%A7%C3%A3o">⇡</a></p> <h3 id="primeira-execução">Primeira execução</h3> <p>A melhor forma para validar a instalação do <code class="language-plaintext highlighter-rouge">docker</code> é realizar uma primeira execução de uma imagem chamada <code class="language-plaintext highlighter-rouge">hello-world</code>, usando o comando <code class="language-plaintext highlighter-rouge">docker container run hello-world</code>.</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Unable to find image <span class="s1">'hello-world:latest'</span> locally
latest: Pulling from library/hello-world
2db29710123e: Pull <span class="nb">complete 
</span>Digest: sha256:aa0cc8055b82dc2509bed2e19b275c8f463506616377219d9642221ab53cf9fe
Status: Downloaded newer image <span class="k">for </span>hello-world:latest

Hello from Docker!
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the <span class="s2">"hello-world"</span> image from the Docker Hub.
    <span class="o">(</span>amd64<span class="o">)</span>
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal.

To try something more ambitious, you can run an Ubuntu container with:
 <span class="nv">$ </span>docker run <span class="nt">-it</span> ubuntu bash

Share images, automate workflows, and more with a free Docker ID:
 https://hub.docker.com/

For more examples and ideas, visit:
 https://docs.docker.com/get-started/
</code></pre></div></div> <p>O log nos mostra que o contêiner foi executado com sucesso. Também mostra que foi a primeira vez que a imagem <code class="language-plaintext highlighter-rouge">hello-world</code> foi usada. Isso fica evidenciado nas cinco primeiras linhas, onde vemos que o <code class="language-plaintext highlighter-rouge">docker</code> procurou pela imagem no repositório local, sem a encontrar. De fato, vejamos o procedimento:</p> <ol> <li>em primeiro lugar, busca-se a imagem no repositório local. No caso acima, não foi encontrada, <code class="language-plaintext highlighter-rouge">Unable to find image 'hello-world:latest' locally</code>;</li> <li>em segundo, busca-se no repositório público quando não encontrada localmente;</li> <li>por fim, se a imagem não for encontrada em nenhum desses dois locais, o comando não será executado.</li> </ol> <p>O repositório oficial do <code class="language-plaintext highlighter-rouge">docker</code> encontra-se <a href="hub.docker.com" target="_blank">aqui</a> e nele imagens oficiais de ferramentas, aplicações e sistemas operacionais são armazenados e disponibilizados para uso geral. Ademais, qualquer usuário pode incluir imagens no repositório, seguindo as políticas específicas de assinatura, e nesse sentido imagens não oficiais também estão disponíveis.</p> <p>Imagens não oficinais são imagens que não tem uma garantia da sua finalidade, pois podem trazer algum malware. Lembre-se que qualquer um pode disponibilizar imagens no repositório do <code class="language-plaintext highlighter-rouge">docker</code>, sem curadoria da <em>docker inc</em>, e o download é feito pela internet. Esses fatores colocam a exigência de garantir que o que está sendo executado é seguro.</p> <p>As imagens trazem alguns metadados, dentre os quais cabe destacar: <code class="language-plaintext highlighter-rouge">tag</code> e <code class="language-plaintext highlighter-rouge">digest</code>. A <code class="language-plaintext highlighter-rouge">tag</code> é utilizada para indicar a versão da imagem, cuja atribuição é feita no momento da geração. O metadado <code class="language-plaintext highlighter-rouge">tag</code> pode funcionar como versionamento, quando, por exemplo, uma <code class="language-plaintext highlighter-rouge">tag</code> nova é gerada quando uma nova versão de uma imagem é compilada. Assim, ao executar <code class="language-plaintext highlighter-rouge">docker container run</code> poderia escolher entre diferentes versões: <code class="language-plaintext highlighter-rouge">docker container run hello-world:1.0</code>.</p> <p>Caso não seja usado <code class="language-plaintext highlighter-rouge">:alguma-tag</code>, por padrão o <code class="language-plaintext highlighter-rouge">docker</code> busca a imagem marcada como <code class="language-plaintext highlighter-rouge">:latest</code>. Dependendo do gerenciamento da imagem, <em>tags</em> marcam ciclos de atualização distintos. Por exemplo, na imagem do <code class="language-plaintext highlighter-rouge">kalilinux</code> existe uma <code class="language-plaintext highlighter-rouge">tag</code> chamada <code class="language-plaintext highlighter-rouge">kali-rolling</code> que indica que a imagem é semanalmente atualizada com novas ferramentas e versões. E existe <code class="language-plaintext highlighter-rouge">kali-last-release</code> que segue uma atualização a cada quatro meses.</p> <p>O segundo metadado é <code class="language-plaintext highlighter-rouge">digest</code> e é usado como um <code class="language-plaintext highlighter-rouge">hash</code> da imagem. No exemplo acima, a imagem <code class="language-plaintext highlighter-rouge">hello-world</code> traz <code class="language-plaintext highlighter-rouge">digest:sha256:aa0cc8055b82dc2509bed2e19b275c8f463506616377219d9642221ab53cf9fe</code>. Essa informação garante que a imagem que chegou localmente é a mesma disponível no <code class="language-plaintext highlighter-rouge">docker hub</code>, isto é, ela não foi alterada durante o processo de download. Lembremo-nos que essa transferência é feita pela internet e técnicas podem ser utilizadas para modificar o conteúdo que será entregue. Acerca disso, é importante não confundir com os identificadores das imagens. Eles são também <em>hashes</em>, porém vinculados ao ambiente local. Nesse sentido, <code class="language-plaintext highlighter-rouge">digest</code> é uma informação que garante a integridade entre a imagem local e a sua origem.</p> <p>Por fim, a partir da primeira execução de uma imagem o <code class="language-plaintext highlighter-rouge">docker</code> não busca mais a imagem no repositório remoto. Ele sempre usurá a imagem local.</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker container run hello-world

Hello from Docker!
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the <span class="s2">"hello-world"</span> image from the Docker Hub.
    <span class="o">(</span>amd64<span class="o">)</span>
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal.

To try something more ambitious, you can run an Ubuntu container with:
 <span class="nv">$ </span>docker run <span class="nt">-it</span> ubuntu bash

Share images, automate workflows, and more with a free Docker ID:
 https://hub.docker.com/

For more examples and ideas, visit:
 https://docs.docker.com/get-started/
</code></pre></div></div> <p><a href="#introdu%C3%A7%C3%A3o">⇡</a></p> <h3 id="imagem-e-contêiner">Imagem e contêiner</h3> <p>Contêineres são instâncias de imagens. Elas são criadas de acordo com uma finalidade que se deseja obter executando um contêiner. Imagens são protótipos para contêineres.</p> <p><code class="language-plaintext highlighter-rouge">Docker</code> possui uma funcionalidade para compilação de imagens a partir de arquivo de instruções, chamado de <code class="language-plaintext highlighter-rouge">dockerfile</code>. O conceito de infraestrutura como código, <code class="language-plaintext highlighter-rouge">IaC</code>, entra em cena. De modo breve, <code class="language-plaintext highlighter-rouge">IaC</code> é a capacidade que algumas ferramentas tem de criar e configurar ambientes a partir de arquivos de instruções, a partir de código. Com isso, os ambientes são criados e configurados igualmente seguindo as instruções dos arquivos em qualquer ambiente que os hospede. Um arquivo <code class="language-plaintext highlighter-rouge">dockerfile</code> suporta uma série de instruções, que podem ser conferidas <a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="external nofollow noopener">aqui</a>, mas uma versão básica de um arquivo seria:</p> <div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> &lt;imagem&gt;:&lt;tag&gt;</span>
<span class="k">RUN </span>&lt;instala dependências&gt;
<span class="k">CMD</span><span class="s"> &lt;comandos que são executados quando há uma solicitação de execução de contêiner, `docker container run`&gt;</span>
</code></pre></div></div> <p>A instrução <code class="language-plaintext highlighter-rouge">FROM</code> é utilizada para referenciar uma imagem mais básica que dará suporte a construção da imagem desejada. Geralmente, uma nova imagem é dependente de outra, cujos recursos são o mínimo necessário. Nesse sentido, o arquivo de instruções modifica a imagem base, <em>enxuta</em>, instalando componentes pela instrução <code class="language-plaintext highlighter-rouge">RUN</code>.</p> <p><code class="language-plaintext highlighter-rouge">FROM</code> e <code class="language-plaintext highlighter-rouge">RUN</code> são instruções que operam no escopo de uma imagem. Durante a construção de uma imagem, ao executar um desses comandos um contêiner temporário é construído para que seja executado o comando e uma imagem é gerada com as novas modificações e, a partir da qual, as demais instruções do arquivo de instruções serão executadas. Por conta disso, <code class="language-plaintext highlighter-rouge">FROM</code> e <code class="language-plaintext highlighter-rouge">RUN</code> são instruções que tem o seu campo de ação delimitado pelo escopo da imagem. Diferente, por exemplo, da instrução <code class="language-plaintext highlighter-rouge">CMD</code>, pela qual é possível executar comandos no escopo do contêiner gerado.</p> <p>Com um <code class="language-plaintext highlighter-rouge">dockerfile</code> configurado, o comando <code class="language-plaintext highlighter-rouge">docker image build</code> é usado. Esse comando faz uma análise do arquivo de instruções e, caso não ocorra problemas, uma imagem é compilada. Essa é uma das funcionalidades que tornou o <code class="language-plaintext highlighter-rouge">docker</code> popular. Isso porque com um <code class="language-plaintext highlighter-rouge">dockerfile</code> é possível automatizar ambientes para a integração e entregas contínuos.</p> <p>Usando um arquivo <code class="language-plaintext highlighter-rouge">dockerfile</code>, cada imagem gerada com o mesmo arquivo terá as mesmas características e consequentemente todos os contêineres, independentemente do ambiente que hospeda os recursos. Assim, os contêineres não dependem do ambiente que os hospede, podendo ser levados ao longo de todo o processo de desenvolvimento até a entrega do artefato final. Com isso, se reduz ou quase se elimina a famosa situação <em>na-minha-máquina-o-problema-não-acontece</em>.</p> <p>Contêineres são objetos que devem ser destruídos ou gerados à medida que for necessário. As imagens tem uma duração maior e tendem a ser versionadas quando mudanças não necessárias. Ainda sobre imagens, elas devem ser consideradas imutáveis e com algum grau de efemeridade. Recomenda-se que a cada modificação o arquivo de instruções seja modificado e versionado, e a imagem recriada com nova versão, evitando-se, assim, inconsistências.</p> <p>Para listar as imagens no ambiente local, usa-se o seguinte comando <code class="language-plaintext highlighter-rouge">docker image ls</code> ou <code class="language-plaintext highlighter-rouge">docker images</code>. E como resultado, temos:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~<span class="nv">$ </span>docker images
REPOSITORY                          TAG        IMAGE ID       CREATED          SIZE
hello-world                         latest     feb5d9fea6a5   16 months ago    13.3kB
</code></pre></div></div> <p>Lembrando que <code class="language-plaintext highlighter-rouge">REPOSITORY</code>, <code class="language-plaintext highlighter-rouge">TAG</code>, <code class="language-plaintext highlighter-rouge">IMAGE ID</code>, <code class="language-plaintext highlighter-rouge">CREATED</code> e <code class="language-plaintext highlighter-rouge">SIZE</code> são metadados utilizados para descrever um arquivo de imagens.</p> <p>Ao executar <code class="language-plaintext highlighter-rouge">docker container run hello-world</code>, o <code class="language-plaintext highlighter-rouge">docker</code> faz download da imagem para o repositório local. Nas sucessivas execuções, a imagem local será requisitada sempre que for usado <code class="language-plaintext highlighter-rouge">hello-world</code> ou <code class="language-plaintext highlighter-rouge">hello-world:latest</code>. Nos casos em que um volume grande de diferentes imagens são utilizadas constantemente, é importante revisar o repositório local para controlar os recursos dispendidos em disco para isso.</p> <p>Os contêineres são imutáveis e efêmeros, a criação e destruição deles não deve ser um problema. Por conta disso, alterações que devem persistir em todas as instâncias não devem ser feitas em um contêiner específico, mas no arquivo <code class="language-plaintext highlighter-rouge">dockerfile</code>, desde o qual gerou-se uma imagem que serve de base para os contêineres. Contêineres são ambientes isolados entre si e do ambiente que os hospeda, exceto quando definidos métodos de interação via stdin/stdout/stderr, volumes compartilhados, e TCP/UDP.</p> <p>Para listar os contêineres em execução, utiliza-se <code class="language-plaintext highlighter-rouge">docker container ls</code> ou <code class="language-plaintext highlighter-rouge">docker ps</code>. E como resultado, pode-se receber uma lista vazio, quando não houver nenhum contêiner em execução.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker container <span class="nb">ls
</span>CONTAINER ID   IMAGE              COMMAND                  CREATED             STATUS             PORTS     NAMES
</code></pre></div></div> <p>No entanto, seguindo o exemplo <code class="language-plaintext highlighter-rouge">docker container run hello-world</code> nada aparece como resultado ao comando <code class="language-plaintext highlighter-rouge">docker container ls</code>. Isso porque ao executar a imagem ela atinge o seu objetivo, qual seja, escrever na saída padrão a mensagem <em>hello-world</em> e a sua execução é encerrada. Por isso, essa execução não aparece na lista de contêineres em execução. Nesses casos, é preciso executar <code class="language-plaintext highlighter-rouge">docker container ls -a</code> ou <code class="language-plaintext highlighter-rouge">docker ps -a</code>.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker ps <span class="nt">-a</span>
CONTAINER ID   IMAGE                 COMMAND           CREATED         STATUS                     PORTS     NAMES
6630496d6fe8   hello-world           <span class="s2">"/hello"</span>          4 seconds ago   Exited <span class="o">(</span>0<span class="o">)</span> 3 seconds ago             laughing_carver
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">CONTAINER ID</code>, <code class="language-plaintext highlighter-rouge">IMAGE</code>, <code class="language-plaintext highlighter-rouge">COMMAND</code>, <code class="language-plaintext highlighter-rouge">CREATED</code>, <code class="language-plaintext highlighter-rouge">STATUS</code>, <code class="language-plaintext highlighter-rouge">PORTS</code>, <code class="language-plaintext highlighter-rouge">NAMES</code> são metadados utilizados para descrever um contâiner.</p> <ul> <li> <code class="language-plaintext highlighter-rouge">CONTAINER ID</code> é um hash que identifica um contêiner, sendo muito utilizado em comandos para referenciar um contêiner. Por exemplo, <code class="language-plaintext highlighter-rouge">docker container stop 6630496d6fe8</code>. É ainda possível utilizar os três primeiros digitos <code class="language-plaintext highlighter-rouge">docker container stop 663</code>. Caso <code class="language-plaintext highlighter-rouge">663</code> se repita entre outros contêineres, um outro digito deve ser informado para especificar;</li> <li> <code class="language-plaintext highlighter-rouge">IMAGE</code> indica qual imagem o contêiner usa como base;</li> <li> <code class="language-plaintext highlighter-rouge">COMMAND</code> indica o comando que é executado quando o contêiner inicia a execução. Geralmente um contêiner tem uma função específica, realizada pela execução de um programa que estará descrito nesse metadado.</li> <li> <code class="language-plaintext highlighter-rouge">STATUS</code> descreve o estado do contêiner e pode assumir <code class="language-plaintext highlighter-rouge">created</code>, <code class="language-plaintext highlighter-rouge">restarting</code>, <code class="language-plaintext highlighter-rouge">running</code>, <code class="language-plaintext highlighter-rouge">removing</code>, <code class="language-plaintext highlighter-rouge">paused</code>, <code class="language-plaintext highlighter-rouge">exited</code> and <code class="language-plaintext highlighter-rouge">dead</code>. Nesse exemplo, o estado <code class="language-plaintext highlighter-rouge">exited</code> indica que o programa executado dentro do contêiner encerrou a execução e retornou um código. Esse código pode indicar execução correta ou incorreta do programa.</li> <li> <code class="language-plaintext highlighter-rouge">PORTS</code> é um metadado que indicará se o contêiner faz alguma ligação por porta com o <code class="language-plaintext highlighter-rouge">host</code> que o hospeda. Geralmente, programas do tipo servidores farão uma ligação com o <code class="language-plaintext highlighter-rouge">host</code>, compartilhando o serviço por meio de uma ligação entre portas (porta-do-host:porta-do-contêiner). Nesses casos será indicado qual ip e porta do host e do contêiner estão ligados.</li> <li> <code class="language-plaintext highlighter-rouge">NAMES</code> é uma alternativa para <code class="language-plaintext highlighter-rouge">CONTAINER ID</code>. Quando não especificado, <code class="language-plaintext highlighter-rouge">docker</code> gera um nome por conta própria. Caso se queira atribuir um nome usa-se a <em>flag</em> <code class="language-plaintext highlighter-rouge">--name</code>.</li> </ul> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="sb">`</span>docker run <span class="nt">--name</span> oi-mundo hello-world<span class="sb">`</span>
<span class="nv">$ </span>docker ps <span class="nt">-a</span>
CONTAINER ID   IMAGE                                             COMMAND                  CREATED         STATUS                     PORTS     NAMES
48222d0fc147   hello-world                                       <span class="s2">"/hello"</span>                 7 seconds ago   Exited <span class="o">(</span>0<span class="o">)</span> 6 seconds ago             oi-mundo
</code></pre></div></div> <p><a href="#introdu%C3%A7%C3%A3o">⇡</a></p> <h3 id="básico-sobre-cliente-docker-linha-de-comando">Básico sobre cliente docker, linha de comando</h3> <p><code class="language-plaintext highlighter-rouge">Docker</code> funciona em uma arquitetura cliente-servidor: um cliente, geralmente linha de comando, solicita via <em>rest</em> <em>api</em> para o servidor, <em>daemon</em>, que execute algum comando. Embora existam outros clientes, a interface de linha de comando (cli - command line interface) é o cliente mais comum e versátil. As <em>flags</em> que adaptam as execuções do comando <code class="language-plaintext highlighter-rouge">docker</code> podem ser encontradas <a href="https://docs.docker.com/engine/reference/commandline/cli/" target="_blank" rel="external nofollow noopener">aqui</a>.</p> <p><code class="language-plaintext highlighter-rouge">docker container run &lt;image&gt;</code> é o comando mais utilizado para instanciar uma imagem como contêiner. No entanto, internamente o comando <code class="language-plaintext highlighter-rouge">run</code> executa outros. Primeiro, é verificado se a imagem indicada está no repositório local ou se é preciso obter a imagem do repositório remoto. O comando equivalente é <code class="language-plaintext highlighter-rouge">docker pull &lt;imagem&gt;</code>. Segundo, o contêiner é criado com base na imagem e, por fim, executado. Respectivamente, são usados os comandos: <code class="language-plaintext highlighter-rouge">docker container create &lt;imagem&gt;</code> e <code class="language-plaintext highlighter-rouge">docker container start -i &lt;imagem&gt;</code>.</p> <p>Contêineres possuem ciclos de vida que são dependentes do objetivo para o qual eles foram criados. Algumas vezes contêineres são criados e executam uma função que os deixam em execução constante. Isso ocorre, geralmente, com contêineres que executam servidores de aplicações, por exemplo, web servers. Em outros casos, como no exemplo utilizado até aqui da imagem <code class="language-plaintext highlighter-rouge">hello-world</code>, o contêiner executa a função designada no atributo <code class="language-plaintext highlighter-rouge">COMMAND</code> e encerra o seu ciclo de vida.</p> <p>Ao encerrar o seu ciclo de vida, um contêiner não é excluído, mas seu status é modificado. Para listá-los usa-se o comando <code class="language-plaintext highlighter-rouge">docker ps -a</code> e para excluí-los o comando <code class="language-plaintext highlighter-rouge">docker container rm &lt;contêiner-id&gt;</code> ou <code class="language-plaintext highlighter-rouge">docker rm &lt;contêiner-id&gt;</code>.</p> <p>Contêineres e imagens tedem a se acumular no sistema local. Para removê-los usa-se os comandos: <code class="language-plaintext highlighter-rouge">docker image rm hello-world</code> ou <code class="language-plaintext highlighter-rouge">docker rmi hello-world</code>, <code class="language-plaintext highlighter-rouge">docker rm &lt;contêiner-id&gt;</code> ou <code class="language-plaintext highlighter-rouge">docker container rm &lt;contêiner-id&gt;</code>.</p> <p>Caso se queira remover imagens em um sistema local, só será possível removê-las se não existir contêineres em qualquer estado. Do contrário, <code class="language-plaintext highlighter-rouge">docker</code> informará: <code class="language-plaintext highlighter-rouge">Error response from daemon: conflict: unable to remove repository reference "hello-world" (must force) - container &lt;container ID&gt; is using its referenced image &lt;image ID&gt;</code>. Nesse caso, precisamos remover os contêineres dependentes, mas antes disso é preciso identificá-los. Em cenários com um número muito grande de contêineres, utilizar do filtro com imagem pode facilitar: <code class="language-plaintext highlighter-rouge">docker container ls -a | grep hello-world</code>.</p> <p>O objetivo desse filtro é trazer todos os identificadores de contêineres que são dependentes da imagem que queremos remover. Os identificadores, ou simplesmente <em>ids</em>, são utilizados pelo <code class="language-plaintext highlighter-rouge">docker</code> em vários contextos, pois identificam um contêiner isoladamente. Funcionam como um hash. Um recurso que facilita o uso deles é utilizar os três primeiros digitos para referenciar um contêiner. Caso os três primeiros não encontrem apenas um contêiner, acrescenta-se mais um digito. Supondo que o <em>id</em> do contêiner a ser removido seja <em>6630496d6fe8</em>, bastaria <code class="language-plaintext highlighter-rouge">docker container rm 663</code>. Acaso <code class="language-plaintext highlighter-rouge">663</code> retorne mais de um contêiner, deve-se usar <code class="language-plaintext highlighter-rouge">6630</code> ou mais digitos.</p> <p>Existem maneiras mais eficientes para remover uma quantidade enorme de contêineres. A mais <em>radical</em> é utilizar a <em>flag</em> <code class="language-plaintext highlighter-rouge">prune</code>, como no exemplo <code class="language-plaintext highlighter-rouge">docker container prune</code>. <code class="language-plaintext highlighter-rouge">Prune</code> é uma <em>flag</em> versátil que pode ser utilizada em vários contextos para fazer uma <em>limpeza</em> de objetos que não estão em um estado de execução: <code class="language-plaintext highlighter-rouge">docker image prune</code>, <code class="language-plaintext highlighter-rouge">docker system prune</code>.</p> <p>Ao remover os contêineres dependentes da imagem <code class="language-plaintext highlighter-rouge">hello-world</code>, será possível remover a imagem usando o comando <code class="language-plaintext highlighter-rouge">docker rmi hello-world</code>. E para confirmar usamos o comando <code class="language-plaintext highlighter-rouge">docker image ls</code>. Outro comando importante em relação a imagens é <code class="language-plaintext highlighter-rouge">docker image pull &lt;nome-da-imagem&gt;</code>, pelo qual imagens podem ser obtidas. E ainda <code class="language-plaintext highlighter-rouge">docker search &lt;nome-da-imagem&gt;</code> que é usado para localizar imagens no repositório.</p> <p>Troquemos de exemplo e busquemos uma imagem que execute a aplicação <em>nginx</em>, famoso servidor web. Por se tratar de uma aplicação amplamente difundida, é bem provável que exista uma imagem oficial no repositório remoto. Para confirmar, usamos o comando <code class="language-plaintext highlighter-rouge">docker search nginx</code>:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NAME                         DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
nginx                        Official build of Nginx.                        17972     <span class="o">[</span>OK]       
linuxserver/nginx            An Nginx container, brought to you by LinuxS…   183                  
bitnami/nginx                Bitnami nginx Docker Image                      150                  <span class="o">[</span>OK]
ubuntu/nginx                 Nginx, a high-performance reverse proxy &amp; we…   75                   
</code></pre></div></div> <p>Os primeiros registros da busca indicam sempre as distribuições oficiais, que devem ter prioridade caso você não tenha confiança em algum fornecedor especifico. Com isso, busca-se garantir integridade da imagem e dos contêineres que serão gerados, reduzindo o risco de gerar algum problema no host ou na aplicação dependentes do contêiner. O campo <em>stars</em> também pode ser um critério de confiança. Ele indica a relevância da imagem na comunidade.</p> <p>Escolhida a imagem, já sabemos como proceder: <code class="language-plaintext highlighter-rouge">docker container run ngix</code>. Essa é a maneira mais simples, embora nesse comando existam outros processos subjacentes, tais como: <code class="language-plaintext highlighter-rouge">docker pull ngix</code>, <code class="language-plaintext highlighter-rouge">docker create ngix</code>, <code class="language-plaintext highlighter-rouge">docker container start ngix</code>.</p> <p>Ao executar <code class="language-plaintext highlighter-rouge">run nginx</code> o terminal congela logo após iniciar o contêiner. Isso é o comportamente padrão do <code class="language-plaintext highlighter-rouge">docker</code> em contêineres que executam tarefas persistentes. Nesses casos, o terminal fica vinculado ao processo que foi iniciado. Se executar o comando <code class="language-plaintext highlighter-rouge">docker ps</code> em outro terminal, o contêiner <code class="language-plaintext highlighter-rouge">nginx</code> estará em execução.</p> <p>Em alguns cenários, opta-se por executar o contêiner desvinculando-o do terminal. Para isso, usa-se o comando <code class="language-plaintext highlighter-rouge">docker container run -d nginx</code>. A flag <code class="language-plaintext highlighter-rouge">-d</code> é a forma simplificada de <code class="language-plaintext highlighter-rouge">--deatach</code>. Ele modifica o comportamento do comando <code class="language-plaintext highlighter-rouge">docker run</code> para que o contêiner seja executado em <em>background</em>. Quando essa flag é usada, apenas é impresso o identificador do contêiner no terminal.</p> <p>Contêineres que executam processos persistentes podem ser colocados em <em>background</em>, desvinculando-o do terminal que o executou: <code class="language-plaintext highlighter-rouge">docker container run -d nginx</code>. Parar um contêiner: <code class="language-plaintext highlighter-rouge">docker container stop &lt;id ou nome&gt;</code>. Remover um contêiner: <code class="language-plaintext highlighter-rouge">docker container rm &lt;id ou nome&gt;</code>, e uma imagem: <code class="language-plaintext highlighter-rouge">docker imagem rm nginx</code>.</p> <p>Em cenários com constante criação e destruição de contêineres, com o tempo é comum que o <code class="language-plaintext highlighter-rouge">docker</code> fique <em>entupido</em> de contêineres e imagens. Para resolver isso é importante fazer uma <em>limpeza</em> usando a <em>flag</em> <code class="language-plaintext highlighter-rouge">prune</code>: <code class="language-plaintext highlighter-rouge">docker container prune</code>, <code class="language-plaintext highlighter-rouge">docker image prune</code>. Ou ainda com a <em>flag</em> <code class="language-plaintext highlighter-rouge">--rm</code> junto ao comando <code class="language-plaintext highlighter-rouge">docker run</code>. Desse modo, <code class="language-plaintext highlighter-rouge">docker</code> removerá o contêiner logo em seguida ao fim de sua execução. Exemplo: <code class="language-plaintext highlighter-rouge">docker container run -it --rm ubuntu</code>.</p> <p><a href="#introdu%C3%A7%C3%A3o">⇡</a></p> <h3 id="executar-e-encerrar-contêineres">Executar e encerrar contêineres</h3> <p>Há diferentes <em>flags</em> que modificam o modo como um contêiner é executado e como ele interage com o terminal que o executou. A maneira mais simples para executar um contêiner é <code class="language-plaintext highlighter-rouge">docker run ubuntu</code>. Há, no entanto, implícito nesse comando outros que compõe o ciclo de criação de um contêiner.</p> <p>Embora a imagem seja de um sistema operacional, o contêiner será encerrado logo após a inicialização. Talvez estivêssemos esperando um comportamente similar a uma máquina virtual, que permanece executando o sistema operacional mesmo que nenhum processo específico seja executado. Contêineres possuem despesas contínuas menores do que em um ambiente virtualizado. Despesas contínuas são despesas que não estão ligadas diretamente a um serviço, processo ou aplicação. Contêineres isolam funções específicas e a executam, incluindo todas as dependências para isso. Em cenários em que a função não é contínua, ao encerrar a função, o contêiner se encerra.</p> <p>No caso da imagem <code class="language-plaintext highlighter-rouge">ubuntu</code>, ela foi construída para executar um processo de bash quando inicializada sem um comando específico. Confirmamos essa hipótese no registro de execução do contêiner.</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker ps <span class="nt">-a</span>

CONTAINER ID   IMAGE              COMMAND                  CREATED         STATUS                     PORTS     NAMES
d1a6ef4dc22b   ubuntu             <span class="s2">"bash"</span>                   4 seconds ago   Exited <span class="o">(</span>0<span class="o">)</span> 3 seconds ago             eager_pike
</code></pre></div></div> <p>O comando <code class="language-plaintext highlighter-rouge">bash</code> foi executado no contêiner, encerrando-se com código <code class="language-plaintext highlighter-rouge">0</code>, indicando sucesso. Códigos de execução dos processos não dependem do contêiner, mas do retorno do programa executado. O contêiner se encerrou e não permitiu nenhuma interação, como se nada tivesse acontecido.</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker run ubuntu <span class="nb">echo</span> <span class="s2">"echoing"</span>
echoing

<span class="nv">$ </span>docker ps <span class="nt">-a</span>
CONTAINER ID   IMAGE                                                          COMMAND                  CREATED          STATUS                      PORTS     NAMES
0bd64f012925   ubuntu                                                         <span class="s2">"echo echoing"</span>           14 seconds ago   Exited <span class="o">(</span>0<span class="o">)</span> 13 seconds ago
</code></pre></div></div> <p>Nessa outra tentativa, obtivemos uma interação. O contêiner se encerra imprimindo no console a palavra <em>echoing</em>, ou seja, o comando <code class="language-plaintext highlighter-rouge">echo echoing</code> foi executado. Por padrão, <code class="language-plaintext highlighter-rouge">docker run</code> não conecta o <em>stream</em> padrão de entrada (<em>sdtin</em>) do contêiner com o terminal, mas conecta o <em>stream</em> padrão de saída (<em>stdout</em>) e o <em>stream</em> padrão de erro (<em>sdterr</em>). Por isso recebemos o resultado da execução do comando. Nesse cenário, em casos em que o processo exige interação de entrada, o processo é encerrado imediatamente. Como foi o caso quando executado <code class="language-plaintext highlighter-rouge">bash</code>. Ou ainda no próximo caso.</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker run ubuntu passwd root
New password: Password change has been aborted.
passwd: Authentication token manipulation error
passwd: password unchanged
</code></pre></div></div> <p>O comando <code class="language-plaintext highlighter-rouge">passwd</code> exige interação de entrada com o usuário. Como nada foi vinculado à entrada padrão, o comando encerra com erro. Para vincular o <em>stream</em> padrão de entrada do contêiner com o terminal, usa-se a <em>flag</em> <code class="language-plaintext highlighter-rouge">-i</code>.</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker run <span class="nt">-i</span> ubuntu passwd root
New password: root
Retype new password: root
passwd: password updated successfully
</code></pre></div></div> <p>Mas nem sempre a entrada padrão virá de um terminal. Pode-se, por exemplo, vincular um <em>pipe</em> de um retorno de um comando, tal como <code class="language-plaintext highlighter-rouge">echo "essa entrada vem de um pipe"</code>, como no exemplo a seguir.</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"essa entrada vem de um pipe"</span> | docker run <span class="nt">-i</span> ubuntu <span class="nb">cat
</span>essa entrada vem de um pipe
</code></pre></div></div> <p>Ou ainda este outro caso, em que a entrada padrão do contêiner é vinculada ao terminal, recebendo um comando atribuído como parâmetro e executando-o. A primeira linha é entrada de dados, a segunda, o retorno do comando <code class="language-plaintext highlighter-rouge">cat</code>. Como foi atribuída a <em>flag</em> <code class="language-plaintext highlighter-rouge">-i</code>, o comando <code class="language-plaintext highlighter-rouge">cat</code> <em>prende</em> a execução, aguardando a interação.</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker run <span class="nt">-i</span> ubuntu <span class="nb">cat
</span>docker <span class="nb">test
</span>docker <span class="nb">test
test </span>docker
<span class="nb">test </span>docker
</code></pre></div></div> <p>Nesse último caso, a entrada padrão do contêiner foi vinculada ao terminal que executou o processo. A primeira linha <em>docker test</em> foi digitada, a segunda, foi resultado do comando <code class="language-plaintext highlighter-rouge">cat</code>. Um último exemplo:</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker run <span class="nt">-i</span> ubuntu rev
1234567890
0987654321
</code></pre></div></div> <p>Embora nesses exemplos tenhamos conseguido interagir com comandos executados dentro do contêiner, enviando e recebendo dados, em certas situações é necessário interagir com um terminal dentro do contêiner. Nesse caso, é necessário alocar um <em>pseudo-TTY</em>, ou seja, um terminal emulado. Para isso, a <em>flag</em> utilizada é <code class="language-plaintext highlighter-rouge">--tty</code> ou <code class="language-plaintext highlighter-rouge">-t</code>.</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker run <span class="nt">-t</span> ubuntu
root@c197f5486a62:/# 
</code></pre></div></div> <p>No exemplo acima, foi requisitado um terminal para o <code class="language-plaintext highlighter-rouge">docker</code> e nos foi entregue <code class="language-plaintext highlighter-rouge">root@c197f5486a62</code>. No entanto, nenhum <em>stream</em> de entrada foi vinculado ao <em>stream</em> de entrada padrão do contêiner. Isso fica mais explícito quando usamos <em>pipe</em> para vincular um <em>stream</em>.</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"from echo"</span> | docker run <span class="nt">-t</span> ubuntu <span class="nb">cat</span>
</code></pre></div></div> <p>O retorno é uma linha em branco. Embora o cat tenha se conectado ao terminal emulado, o terminal emulado não se conectou à entrada do <em>pipe</em> porque não foi designado ao <code class="language-plaintext highlighter-rouge">docker</code> que ele exposse o <em>stream</em> de entrada padrão para receber entrada de dados externo. Lembremos que um contêiner é totalmente isolado, exceto se configurado para se conectar com o <em>mundo exterior</em>, e exceto pelo <em>sdtout</em> e <em>sdterr</em>.</p> <p>Com isso, no geral e na maioria das vezes é interessante criar o contêiner com <code class="language-plaintext highlighter-rouge">-it</code>, <code class="language-plaintext highlighter-rouge">docker create -it ubuntu</code> ou <code class="language-plaintext highlighter-rouge">docker run -it ubuntu</code>. Caso se opte por não usar <code class="language-plaintext highlighter-rouge">docker run</code>, quando o contêiner for executado, deve-se vincular o terminal ao contêiner <code class="language-plaintext highlighter-rouge">docker start -ai &lt;id&gt;</code>.</p> <p>Apenas como registro, <code class="language-plaintext highlighter-rouge">-it</code> é a forma simplificada para <code class="language-plaintext highlighter-rouge">--interactive</code> e <code class="language-plaintext highlighter-rouge">--tty</code>.</p> <p><code class="language-plaintext highlighter-rouge">docker run -d -it --name looper ubuntu sh -c 'while true; do date; sleep 1; done'</code> é um comando que traz uma complexidade maior, embora conheçamos algumas das <em>flags</em>; <code class="language-plaintext highlighter-rouge">-d</code>, <code class="language-plaintext highlighter-rouge">-it</code>; e parâmetros <code class="language-plaintext highlighter-rouge">sh -c 'while true; do date; sleep 1; done'</code>.</p> <ul> <li> <code class="language-plaintext highlighter-rouge">-d</code> executa o contêiner em <em>background</em>;</li> <li> <code class="language-plaintext highlighter-rouge">-it</code> cria um terminal e abre o <em>stream</em> padrão de entrada do contêiner que poderá ser vinculado ao terminal;</li> <li> <code class="language-plaintext highlighter-rouge">--name</code> cria o contêiner com um nome inicial, embora quando não informado o comando <code class="language-plaintext highlighter-rouge">docker</code> gera um nome aleatório. O nome do contêiner é um substituto para o <em>id</em>, podendo explicitar mais claramente a função do contêiner;</li> <li> <code class="language-plaintext highlighter-rouge">sh -c 'while true; do date; sleep 1; done'</code> comando que será executado no shell dentro do contêiner. O comando executa uma repetição infinita, <code class="language-plaintext highlighter-rouge">while true</code>, que imprime a data e a hora, <code class="language-plaintext highlighter-rouge">do date</code>, em intervalos de um segundo, <code class="language-plaintext highlighter-rouge">sleep 1</code>;</li> </ul> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker run <span class="nt">-d</span> <span class="nt">-it</span> <span class="nt">--name</span> looper ubuntu sh <span class="nt">-c</span> <span class="s1">'while true; do date; sleep 1; done'</span>
881a12f8713635d23166730a9bbffbb6d4fe5fbeb20fad5f578c6c1cd2f4a2a6
</code></pre></div></div> <p>O retorno do comando é, como esperado, o hash de identificação. Isso porque utilizamos a <em>flag</em> <code class="language-plaintext highlighter-rouge">-d</code>. Para verificar se o contêiner está em execução <code class="language-plaintext highlighter-rouge">docker container ls</code> ou <code class="language-plaintext highlighter-rouge">docker ps</code>. E ainda podemos acessar o que o contêiner está enviando via <em>stdout</em>.</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker logs <span class="nt">-f</span> looper
Wed Jan 25 01:20:10 UTC 2023
Wed Jan 25 01:20:11 UTC 2023
Wed Jan 25 01:20:12 UTC 2023
Wed Jan 25 01:20:13 UTC 2023
Wed Jan 25 01:20:14 UTC 2023
Wed Jan 25 01:20:15 UTC 2023
</code></pre></div></div> <p>Em outro terminal é possível pausar o contêiner <code class="language-plaintext highlighter-rouge">docker pause looper</code> e o registro de log irá pausar também. Para retornar <code class="language-plaintext highlighter-rouge">docker unpause looper</code>.</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker attach looper
Wed Jan 25 01:28:26 UTC 2023
Wed Jan 25 01:28:27 UTC 2023
Wed Jan 25 01:28:28 UTC 2023
Wed Jan 25 01:28:29 UTC 2023
Wed Jan 25 01:28:30 UTC 2023
Wed Jan 25 01:28:31 UTC 2023
</code></pre></div></div> <p>Nesse último caso, usando o comando <code class="language-plaintext highlighter-rouge">attach</code> é possível conectar diretamente ao terminal dentro do <em>docker</em>, que no nosso exemplo está executando o comando <code class="language-plaintext highlighter-rouge">'while true; do date; sleep 1; done'</code> e imprimindo no terminal. Caso o comando seja encerrado, por exemplo <code class="language-plaintext highlighter-rouge">ctrl + c</code>, o contêiner se encerrará.</p> <p>Para evitar com que contêineres sejam encerrados a partir de outros terminais, é possível utilizar a <em>flag</em> <code class="language-plaintext highlighter-rouge">--no-stdin</code> que não recebe entrada de dados.</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker ps
CONTAINER ID   IMAGE                      COMMAND                  CREATED        STATUS       PORTS     NAMES

nonada@nonada:~<span class="nv">$ </span>docker start looper
looper
nonada@nonada:~<span class="nv">$ </span>docker attach <span class="nt">--no-stdin</span> looper
Wed Jan 25 01:35:30 UTC 2023
Wed Jan 25 01:35:31 UTC 2023
Wed Jan 25 01:35:32 UTC 2023
Wed Jan 25 01:35:33 UTC 2023
Wed Jan 25 01:35:34 UTC 2023
^C
nonada@nonada:~<span class="nv">$ </span>docker ps
CONTAINER ID   IMAGE                      COMMAND                  CREATED          STATUS          PORTS     NAMES
881a12f87136   ubuntu                     <span class="s2">"sh -c 'while true; …"</span>   15 minutes ago   Up 22 seconds             looper
</code></pre></div></div> <p>O contêiner continua em execução, <code class="language-plaintext highlighter-rouge">ctrl + c</code> apenas desconecta do <em>sdtout</em>. Em um contêiner em execução, podemos criar um novo processo de terminal e acessá-lo.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker exec -it looper bash
root@df9319bd49cb:/#
root@df9319bd49cb:/# ps aux
USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root           1  0.1  0.0   2888   988 pts/0    Ss+  10:49   0:00 sh -c while true; do date; sleep 1; done
root          53  0.2  0.0   4624  3516 pts/1    Ss   10:49   0:00 bash
root          86  0.0  0.0   2788  1032 pts/0    S+   10:49   0:00 sleep 1
root          87  0.0  0.0   7060  1576 pts/1    R+   10:49   0:00 ps aux
</code></pre></div></div> <p>Com <code class="language-plaintext highlighter-rouge">ps aux</code> notamos que nosso processo inicial está em execução. Algumas vezes usar <code class="language-plaintext highlighter-rouge">docker stop</code> pode ser lento, pois ele segue um tempo de espera para garantir que todos as aplicações se encerrem depois de um <code class="language-plaintext highlighter-rouge">SIGTERM</code> com <code class="language-plaintext highlighter-rouge">SIGKILL</code>. Caso seja preciso encerrar um contêiner mais rapidamente, há algumas opções.</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker <span class="nb">kill </span>looper
docker <span class="nb">rm </span>looper

docker run <span class="nt">-d</span> <span class="nt">--rm</span> <span class="nt">-it</span> <span class="nt">--name</span> looper-it ubuntu sh <span class="nt">-c</span> <span class="s1">'while true; do date; sleep 1; done'</span>
</code></pre></div></div> <p>As duas primeiras linhas encerram a execução de um contêiner e removem-no. A terceira é uma maneira de criar um contêiner de tal modo que ao encerrar o processo principal, o contêiner é removido.</p> <p><a href="#introdu%C3%A7%C3%A3o">⇡</a></p> <h3 id="mergulhando-nas-imagens">Mergulhando nas imagens</h3> <p>Imagens são protótipos básicos para construção de outras imagens e instanciação de contêineres. Há dois lugares básicos de armazenamento de imagens: repositório local e repositório público do <em>docker</em>. E como já vimos é possível localizar imagens no repositório público pelo comando <code class="language-plaintext highlighter-rouge">docker search postgres</code>.</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker search postgres
NAME                               DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
postgres                           The PostgreSQL object-relational database sy…   11897     <span class="o">[</span>OK]       
bitnami/postgresql                 Bitnami PostgreSQL Docker Image                 178                  <span class="o">[</span>OK]
circleci/postgres                  The PostgreSQL object-relational database sy…   30                   
ubuntu/postgres                    PostgreSQL is an open <span class="nb">source </span>object-relation…   23                   
bitnami/postgresql-repmgr                                                          19                   
rapidfort/postgresql               RapidFort optimized, hardened image <span class="k">for </span>Post…   16                   
</code></pre></div></div> <p>As imagens que são oficiais, além da manutenção dos autores da imagem, são também cuidadas e revistas pela <em>docker inc.</em>. Essas imagens oficiais seguem um padrão de criação que visa disponibilizar uma base de sistema operacional essencial que sirva de começo para a maioria dos usuários; disponibilizar imagens de ambientes de linguagens de programação populares, bancos de dados e outros serviços de modo similar ao que os serviços PaaS oferecem; servem de exemplo das melhores práticas para <code class="language-plaintext highlighter-rouge">dockerfile</code>; garantem que atualizações de segurança sejam aplicadas em tempo hábil.</p> <p>Além do <em>ok</em> na coluna <em>official</em>, imagens oficiais não possuem o prefixo da organização. Já <code class="language-plaintext highlighter-rouge">bitnami/postgresql</code> não é uma imagem oficial, o nome está com o prefixo da organização, mas a coluna <code class="language-plaintext highlighter-rouge">automated</code> está como <em>ok</em>, o que indica que essa imagem é construída diretamente do repositório fonte.</p> <p><code class="language-plaintext highlighter-rouge">Docker hub</code> é o repositório oficial do <code class="language-plaintext highlighter-rouge">docker</code> para imagens oficiais e não-oficiais. No entanto, ele não é o único. Atualmente existe <code class="language-plaintext highlighter-rouge">quay.io</code>, vinculado à <code class="language-plaintext highlighter-rouge">red hat</code>, que disponibiliza imagens para <code class="language-plaintext highlighter-rouge">docker</code>, <code class="language-plaintext highlighter-rouge">podman</code> e <code class="language-plaintext highlighter-rouge">rkt</code>. Embora não se possa utilizar <code class="language-plaintext highlighter-rouge">docker search</code> é possível indicar um endereço para o contêiner <code class="language-plaintext highlighter-rouge">docker pull quay.io/nordstrom/hello-world:2.0</code>.</p> <p>Todas as imagens possuem uma <em>tag</em> como, por exemplo, <em>latest</em>, que indica que é a última versão contruída e enviada ao repositório. Mas cada mantenedor estabele seus próprios critérios em relação as <em>tags</em> e o que elas indicam. Por exemplo, a imagem <em>ubuntu</em>, além de <em>latest</em>, possui uma série de outras tags, dentre elas, algumas que indicam versões específicas, tais como <code class="language-plaintext highlighter-rouge">ubuntu:23.04</code>, <code class="language-plaintext highlighter-rouge">ubuntu:22.10</code>, <code class="language-plaintext highlighter-rouge">ubuntu:22.04</code>, <code class="language-plaintext highlighter-rouge">ubuntu:18.04</code>.</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker pull ubuntu:23.04
23.04: Pulling from library/ubuntu
2627e5235478: Pull <span class="nb">complete 
</span>Digest: sha256:2ca8fe42bcc2979f66dd80c2987a43cfc5502626094b7f838f89759173f3956b
Status: Downloaded newer image <span class="k">for </span>ubuntu:23.04
docker.io/library/ubuntu:23.04
</code></pre></div></div> <p>Imagens são construídas por diferentes camadas e metadados. Em algumas circunstâncias as camadas podem otimizar o processo de obtenção de uma outra imagem, quando essa compartilha uma camada base que já está disponível localmente. Geralmente essa camada base é outra imagem. Imagens permitem <em>tags</em> e podem ser entiquetadas com o comando <code class="language-plaintext highlighter-rouge">docker tag</code>. O nome de uma imagem é composto de três partes: <code class="language-plaintext highlighter-rouge">repositório/organização/imagem:tag</code>. As imagens que são oficinais, são indicadas apenas por <code class="language-plaintext highlighter-rouge">imagem:tag</code>.</p> <p><a href="#introdu%C3%A7%C3%A3o">⇡</a></p> <h3 id="construindo-imagens">Construindo imagens</h3> <p>Uma das grandes funcionalidades do <code class="language-plaintext highlighter-rouge">docker</code> é permitir a criação de imagens customizadas com o arquivo de instruções <code class="language-plaintext highlighter-rouge">dockerfile</code>. Sigamos um experimento sobre isso.</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">touch </span>docker-custom.sh
<span class="nv">$ </span><span class="nb">ls </span>docker-custom.sh 
docker-custom.sh
<span class="nv">$ </span><span class="nb">echo</span> <span class="se">\#\!</span>/bin/sh <span class="o">&gt;</span> docker-custom.sh
<span class="nv">$ </span><span class="nb">echo</span> <span class="s1">'echo "Hello, docker!"'</span> <span class="o">&gt;&gt;</span> docker-custom.sh
<span class="nv">$ </span><span class="nb">cat </span>docker-custom.sh
<span class="c">#!/bin/bash</span>
<span class="nb">echo</span> <span class="s2">"Hello, docker!"</span>
<span class="nv">$ </span>
</code></pre></div></div> <p>Testar <code class="language-plaintext highlighter-rouge">docker-custom.sh</code>.</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">chmod</span> +x docker-custom.sh
<span class="nv">$ </span>./docker-custom.sh 
Hello, docker!
<span class="nv">$ </span>
</code></pre></div></div> <p>A imagem acima irá executar o programa <code class="language-plaintext highlighter-rouge">docker-custom.sh</code>, mas para isso ela precisa de uma base que execute arquivos <code class="language-plaintext highlighter-rouge">.sh</code>. Geralmente, uma imagem se baseia em outra que tem uma versão <em>enxuta</em> do linux, a partir da qual outras ferramentas são instaladas para atingir o propósito ao qual os contêineres gerados a partir dela se destinam. <code class="language-plaintext highlighter-rouge">Dockerfile</code> é um arquivo texto, então podemos usar editor de texto para escrever nele.</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">touch </span>Dockerfile
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"# Start from the alpine image that is smaller but no fancy tools"</span>
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"FROM alpine:3.13"</span> <span class="o">&gt;&gt;</span> Dockerfile
<span class="nv">$ </span><span class="nb">echo</span> <span class="o">&gt;&gt;</span> Dockerfile
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"# Use /usr/src/app as our workdir. The following instructions will be executed in this location."</span> <span class="o">&gt;&gt;</span> Dockerfile
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"WORKDIR /usr/src/app"</span> <span class="o">&gt;&gt;</span> Dockerfile
<span class="nv">$ </span><span class="nb">echo</span> <span class="o">&gt;&gt;</span> Dockerfile
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"# Copy the docker-custom.sh file from this location to /usr/src/app/ creating /usr/src/app/docker-custom.sh"</span> <span class="o">&gt;&gt;</span> Dockerfile
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"COPY docker-custom.sh ."</span> <span class="o">&gt;&gt;</span> Dockerfile
<span class="nv">$ </span><span class="nb">echo</span> <span class="o">&gt;&gt;</span> Dockerfile
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"# Alternatively, if we skipped chmod earlier, we can add execution permissions during the build."</span> <span class="o">&gt;&gt;</span> Dockerfile
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"# RUN chmod +x docker-custom.sh"</span> <span class="o">&gt;&gt;</span> Dockerfile
<span class="nv">$ </span><span class="nb">echo</span> <span class="o">&gt;&gt;</span> Dockerfile
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"# When running docker run the command will be ./docker-custom.sh"</span> <span class="o">&gt;&gt;</span> Dockerfile
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"CMD ./docker-custom.sh"</span> <span class="o">&gt;&gt;</span> Dockerfile
<span class="nv">$ </span><span class="nb">echo</span> <span class="o">&gt;&gt;</span> Dockerfile
<span class="nv">$ </span><span class="nb">cat </span>Dockerfile
<span class="c"># Start from the alpine image that is smaller but no fancy tools</span>
FROM alpine:3.13

<span class="c"># Use /usr/src/app as our workdir. The following instructions will be executed in this location.</span>
WORKDIR /usr/src/app

<span class="c"># Copy the docker-custom.sh file from this location to /usr/src/app/ creating /usr/src/app/docker-custom.sh</span>
COPY docker-custom.sh <span class="nb">.</span>

<span class="c"># Alternatively, if we skipped chmod earlier, we can add execution permissions during the build.</span>
<span class="c"># RUN chmod +x docker-custom.sh</span>

<span class="c"># When running docker run the command will be ./docker-custom.sh</span>
CMD ./docker-custom.sh
</code></pre></div></div> <p>Vamos compilar uma imagem usando <code class="language-plaintext highlighter-rouge">docker build</code>, onde <code class="language-plaintext highlighter-rouge">-t hello-docker-custom</code> será o nome da imagem, o qual poderia ser acrescido de uma outra <em>tag</em> tal como <code class="language-plaintext highlighter-rouge">-t hello-docker-custom:v1</code> ou <code class="language-plaintext highlighter-rouge">-t hello-docker-custom:latest</code>. <code class="language-plaintext highlighter-rouge">.</code> designa o local do arquivo <code class="language-plaintext highlighter-rouge">dokerfile</code>.</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker build <span class="nb">.</span> <span class="nt">-t</span> hello-docker-custom
Sending build context to Docker daemon  3.584kB
Step 1/4 : FROM alpine:3.13
3.13: Pulling from library/alpine
72cfd02ff4d0: Pull <span class="nb">complete 
</span>Digest: sha256:469b6e04ee185740477efa44ed5bdd64a07bbdd6c7e5f5d169e540889597b911
Status: Downloaded newer image <span class="k">for </span>alpine:3.13
 <span class="nt">---</span><span class="o">&gt;</span> 6b5c5e00213a
Step 2/4 : WORKDIR /usr/src/app
 <span class="nt">---</span><span class="o">&gt;</span> Running <span class="k">in </span>d40df5c012b6
Removing intermediate container d40df5c012b6
 <span class="nt">---</span><span class="o">&gt;</span> a7e261938b8b
Step 3/4 : COPY docker-custom.sh <span class="nb">.</span>
 <span class="nt">---</span><span class="o">&gt;</span> 4fdfefd0f0f4
Step 4/4 : CMD ./docker-custom.sh
 <span class="nt">---</span><span class="o">&gt;</span> Running <span class="k">in </span>aca5cee54539
Removing intermediate container aca5cee54539
 <span class="nt">---</span><span class="o">&gt;</span> 0b58abcb10ac
Successfully built 0b58abcb10ac
Successfully tagged hello-docker-custom:latest
<span class="nv">$ </span>
<span class="nv">$ </span>docker images
REPOSITORY                                                     TAG        IMAGE ID       CREATED         SIZE
hello-docker-custom                                            latest     0b58abcb10ac   6 minutes ago   5.62MB
alpine                                                         3.13       6b5c5e00213a   5 months ago    5.62MB
<span class="err">$</span>
</code></pre></div></div> <p>Finalizada a execução, podemos testar.</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker run hello-docker-custom
Hello, docker!
</code></pre></div></div> <p>Na construção da imagem acima podemos notar as camadas que a compõem. As camadas tem multiplas funções. Por um lado, pode ser interessante limitar o número de camadas para reduzir o espaço gasto com armazenamento, porém cada camada funciona como <em>cache</em> durante a construção de imagens. Caso apenas a última linha do <em>dockerfile</em> seja editada, o comando que faz a construção da imagem inicia a partir da camada editada e pula as camadas das seções anteriores. Isso permite construir imagens que podem ser usadas em <em>pipelines</em> mais rápidos.</p> <p>Há duas formas de modificarmos a imagem <code class="language-plaintext highlighter-rouge">hello-docker-custom</code>. Uma das opções é modificar o arquivo de instruções, incluindo nele as modificações desejadas. A segunda opção é modificar um contêiner gerado pela imagem e criar uma imagem a partir do contêiner modificado. A primeira opção é considerada a prática mais sustentável e adequada para automação de contêineres, pois o arquivo de intruções é de fácil análise e checagem de integridade. Não obstante, sigamos com um exemplo do segundo cenário.</p> <p>O objetivo desse exemplo é incluir um arquivo no contêiner executado a partir da imagem <code class="language-plaintext highlighter-rouge">hello-docker-custom</code> e, em seguida, gerar uma imagem a partir do contêiner modificado.</p> <ol> <li>acessar o shell de uma instância de contêiner porque a nossa imagem não tem um processo constante; <div class="language-shell highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker run <span class="nt">-it</span> hello-docker-custom sh
</code></pre></div> </div> </li> <li>em outro terminal, criar o arquivo que queremos copiar para o contêiner; <div class="language-shell highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">touch </span>additional-file
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"test file new image"</span> <span class="o">&gt;</span> additional-file
</code></pre></div> </div> </li> <li>copiar o arquivo usando o comando de cópia do <code class="language-plaintext highlighter-rouge">docker</code>, pelo qual é possível copiar arquivos externos diretamente para dentro do contêiner; ~~~ shell $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 7d00fcbd2b12 hello-docker-custom “sh” 7 minutes ago Up 7 minutes sharp_northcutt</li> </ol> <p>$ docker cp ./additional-file sharp_northcutt:/usr/src/app/</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
4. confirmar a cópia no terminal do passo 1;
~~~ shell
/usr/src/app # ls -l
total 8
-rw-rw-r--    1 1001     1001            20 Jan 25 21:44 additional-file
-rwxrwxr-x    1 root     root            32 Jan 25 14:10 docker-custom.sh
/usr/src/app # 
</code></pre></div></div> <ol> <li>listar as modificações em um contêiner comparando com a imagem base usando o comando <code class="language-plaintext highlighter-rouge">docker diff</code>. Nesse exemplo estamos usando as três primeiras letras do <em>id</em>. O comando retorna uma lista, identificando as mudanças com as letras A = adicionado, D = deletado, C = modificado. <code class="language-plaintext highlighter-rouge">A /root/.ash_history</code> é o arquivo de histórico criado pelo shell, e como consequência o diretório <code class="language-plaintext highlighter-rouge">C /root</code> aparece como modificado. O mesmo vale para o arquivo adicionado <code class="language-plaintext highlighter-rouge">A /usr/src/app/additional-file</code>, desde o qual os subdiretórios também aparecem como modificados. <div class="language-shell highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker diff 7d0
C /root
A /root/.ash_history
C /usr
C /usr/src
C /usr/src/app
A /usr/src/app/additional-file
</code></pre></div> </div> </li> <li>validar as alterações gerando uma nova imagem. <div class="language-shell highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker commit sharp_northcutt hello-docker-custom-add-file
<span class="nv">$ </span>docker images
REPOSITORY                                                     TAG        IMAGE ID       CREATED         SIZE
hello-docker-custom-add-file                                   latest     2b46f876538d   6 seconds ago   5.62MB
hello-docker-custom                                            latest     3c67903d7912   8 hours ago     5.62MB
</code></pre></div> </div> </li> </ol> <p>No entanto, como mencionado, essa técnica é a menos adequada para manter a confiabilidade e integridade das imagens e dos contêineres em um ambiente de integração e entregas contínuos. O melhor é introduzir a alteração no arquivo de intruções e compilar uma nova versão da imagem.</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">touch </span>Dockerfile
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"# Start from the alpine image that is smaller but no fancy tools"</span>
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"FROM alpine:3.13"</span> <span class="o">&gt;&gt;</span> Dockerfile
<span class="nv">$ </span><span class="nb">echo</span> <span class="o">&gt;&gt;</span> Dockerfile
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"# Use /usr/src/app as our workdir. The following instructions will be executed in this location."</span> <span class="o">&gt;&gt;</span> Dockerfile
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"WORKDIR /usr/src/app"</span> <span class="o">&gt;&gt;</span> Dockerfile
<span class="nv">$ </span><span class="nb">echo</span> <span class="o">&gt;&gt;</span> Dockerfile
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"# Copy the docker-custom.sh file from this location to /usr/src/app/ creating /usr/src/app/docker-custom.sh"</span> <span class="o">&gt;&gt;</span> Dockerfile
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"COPY docker-custom.sh ."</span> <span class="o">&gt;&gt;</span> Dockerfile
<span class="nv">$ </span><span class="nb">echo</span> <span class="o">&gt;&gt;</span> Dockerfile
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"# Copy the additional-file file from this location to /usr/src/app/ creating /usr/src/app/additional-file"</span> <span class="o">&gt;&gt;</span> Dockerfile
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"COPY additional-file ."</span> <span class="o">&gt;&gt;</span> Dockerfile
<span class="nv">$ </span><span class="nb">echo</span> <span class="o">&gt;&gt;</span> Dockerfile
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"# Alternatively, if we skipped chmod earlier, we can add execution permissions during the build."</span> <span class="o">&gt;&gt;</span> Dockerfile
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"# RUN chmod +x docker-custom.sh"</span> <span class="o">&gt;&gt;</span> Dockerfile
<span class="nv">$ </span><span class="nb">echo</span> <span class="o">&gt;&gt;</span> Dockerfile
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"# When running docker run the command will be ./docker-custom.sh"</span> <span class="o">&gt;&gt;</span> Dockerfile
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"CMD ./docker-custom.sh"</span> <span class="o">&gt;&gt;</span> Dockerfile
<span class="nv">$ </span><span class="nb">echo</span> <span class="o">&gt;&gt;</span> Dockerfile
<span class="nv">$ </span><span class="nb">cat </span>Dockerfile
<span class="c"># Start from the alpine image that is smaller but no fancy tools</span>
FROM alpine:3.13

<span class="c"># Use /usr/src/app as our workdir. The following instructions will be executed in this location.</span>
WORKDIR /usr/src/app

<span class="c"># Copy the docker-custom.sh file from this location to /usr/src/app/ creating /usr/src/app/docker-custom.sh</span>
COPY docker-custom.sh <span class="nb">.</span>

<span class="c"># Copy the additional-file file from this location to /usr/src/app/ creating /usr/src/app/additional-file</span>
COPY additional-file <span class="nb">.</span>

<span class="c"># Alternatively, if we skipped chmod earlier, we can add execution permissions during the build.</span>
<span class="c"># RUN chmod +x docker-custom.sh</span>

<span class="c"># When running docker run the command will be ./docker-custom.sh</span>
CMD ./docker-custom.sh

<span class="nv">$ </span>docker build <span class="nb">.</span> <span class="nt">-t</span> hello-docker-custom:v2
Sending build context to Docker daemon  4.608kB
Step 1/5 : FROM alpine:3.13
 <span class="nt">---</span><span class="o">&gt;</span> 6b5c5e00213a
Step 2/5 : WORKDIR /usr/src/app
 <span class="nt">---</span><span class="o">&gt;</span> Using cache
 <span class="nt">---</span><span class="o">&gt;</span> 9eb188839ca5
Step 3/5 : COPY docker-custom.sh <span class="nb">.</span>
 <span class="nt">---</span><span class="o">&gt;</span> Using cache
 <span class="nt">---</span><span class="o">&gt;</span> 3f993b722931
Step 4/5 : COPY additional-file <span class="nb">.</span>
 <span class="nt">---</span><span class="o">&gt;</span> 6c33f7f73477
Step 5/5 : CMD ./docker-custom.sh
 <span class="nt">---</span><span class="o">&gt;</span> Running <span class="k">in </span>472ff4ec3b7b
Removing intermediate container 472ff4ec3b7b
 <span class="nt">---</span><span class="o">&gt;</span> 79bd587fa113
Successfully built 79bd587fa113
Successfully tagged hello-docker-custom:v2
<span class="nv">$ </span>docker images
REPOSITORY                                                     TAG        IMAGE ID       CREATED         SIZE
hello-docker-custom                                            v2         79bd587fa113   6 seconds ago   5.62MB
hello-docker-custom-add-file                                   latest     2b46f876538d   9 minutes ago   5.62MB
hello-docker-custom                                            latest     3c67903d7912   8 hours ago     5.62MB
<span class="nv">$ </span>docker run <span class="nt">-it</span> hello-docker-custom:v2 sh
/usr/src/app <span class="c"># ls -l</span>
total 8
<span class="nt">-rw-rw-r--</span>    1 root     root            20 Jan 25 22:11 additional-file
<span class="nt">-rwxrwxr-x</span>    1 root     root            32 Jan 25 14:10 docker-custom.sh
/usr/src/app <span class="c"># </span>
</code></pre></div></div> <p><a href="#introdu%C3%A7%C3%A3o">⇡</a></p> <h3 id="definindo-condições-iniciais-do-contêiner">Definindo condições iniciais do contêiner</h3> <p>Nesta seção iniciaremos por configurar um contêiner de modo interativo, ou seja, a partir de um contêiner criado sobre uma imagem base de um sistema operacional, realizaremos as instalação necessárias para execução da aplicação desejada. A imagem que buscamos deverá conseguir executar a aplicação <em>youtube-dl</em>, uma ferramenta de linha de comando que faz download de vídeos. Segundo <a href="https://ytdl-org.github.io/youtube-dl/download.html" target="_blank" rel="external nofollow noopener">a documentação</a>, a única dependência é python em uma das seguintes versões 2.6, 2.7, 3.2+.</p> <ol> <li>primeiro passo é executar um contêiner com ubuntu:18.04. <div class="language-shell highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker run <span class="nt">-it</span> ubuntu:18.04
Unable to find image <span class="s1">'ubuntu:18.04'</span> locally
18.04: Pulling from library/ubuntu
a055bf07b5b0: Pull <span class="nb">complete 
</span>Digest: sha256:c1d0baf2425ecef88a2f0c3543ec43690dc16cc80d3c4e593bb95e4f45390e45
Status: Downloaded newer image <span class="k">for </span>ubuntu:18.04
root@2b927087df24:/#
</code></pre></div> </div> </li> <li>estamos com um contêiner executando ubuntu. No entanto, as imagens de sistemas operacionais são geralmente <em>enxutas</em>, com poucas aplicações, inclusive as mais básicas, garantindo com que no contêiner seja instalado apenas o que é necessário para o seu propósito. Uma das ferramentas que precisaremos é o <code class="language-plaintext highlighter-rouge">curl</code>, utilizado basicamente para transferir dados através de vários protocolos, e dentre esses o <code class="language-plaintext highlighter-rouge">http</code>. Precisaremos dele para que na hora de montar o contêiner a aplicação <em>youtube-dl</em> seja obtida do seu endereço web oficial. <div class="language-shell highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>root@2b927087df24:/# curl <span class="nt">--help</span>
bash: curl: <span class="nb">command </span>not found
<span class="c">#</span>
apt update <span class="o">&amp;&amp;</span> apt <span class="nb">install</span> <span class="nt">-y</span> curl
root@2b927087df24:/# curl <span class="nt">--help</span>
Usage: curl <span class="o">[</span>options...] &lt;url&gt;
</code></pre></div> </div> </li> <li>instalação da aplicação. <div class="language-shell highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>root@2b927087df24:/# curl <span class="nt">-L</span> https://yt-dl.org/downloads/latest/youtube-dl <span class="nt">-o</span> /usr/local/bin/youtube-dl
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                              Dload  Upload   Total   Spent    Left  Speed
100     3  100     3    0     0      1      0  0:00:03  0:00:02  0:00:01     1
100     3    0     3    0     0      0      0 <span class="nt">--</span>:--:--  0:00:03 <span class="nt">--</span>:--:--     0
  0     0    0     0    0     0      0      0 <span class="nt">--</span>:--:--  0:00:03 <span class="nt">--</span>:--:--     0
100 1794k  100 1794k    0     0   375k      0  0:00:04  0:00:04 <span class="nt">--</span>:--:-- 3444k
<span class="c">#</span>
root@2b927087df24:/# <span class="nb">chmod </span>a+rx /usr/local/bin/youtube-dl
root@2b927087df24:/# youtube-dl 
/usr/bin/env: <span class="s1">'python'</span>: No such file or directory
</code></pre></div> </div> </li> <li>embora a aplicação esteja instalada, com permissões atribuidas, ela ainda necessita do python instalado. <div class="language-shell highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>root@2b927087df24:/# python <span class="nt">--version</span>
bash: python: <span class="nb">command </span>not found
<span class="c">#</span>
root@2b927087df24:/# apt <span class="nb">install</span> <span class="nt">-y</span> python
root@2b927087df24:/# python <span class="nt">--version</span>
Python 2.7.17
</code></pre></div> </div> </li> <li>agora nossa aplicação pode executar. Mas, na sua primeira execução, somos alertados sobre a variável de ambiente LC_ALL, cuja função é não restringir o nome dos arquivos por caracteres inválidos. <div class="language-shell highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>root@2b927087df24:/# youtube-dl
WARNING: Assuming <span class="nt">--restrict-filenames</span> since file system encoding cannot encode all characters. Set the LC_ALL environment variable to fix this.
Usage: youtube-dl <span class="o">[</span>OPTIONS] URL <span class="o">[</span>URL...]
<span class="c">#</span>
youtube-dl: error: You must provide at least one URL.
Type youtube-dl <span class="nt">--help</span> to see a list of all options.
<span class="c">#</span>
root@2b927087df24:/# <span class="nb">export </span><span class="nv">LC_ALL</span><span class="o">=</span>C.UTF-8
root@2b927087df24:/# <span class="nb">echo</span> <span class="nv">$LC_ALL</span>
C.UTF-8
</code></pre></div> </div> </li> <li>por fim, a aplicação está rodando no contêiner. <div class="language-shell highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>root@2b927087df24:/# youtube-dl https://imgur.com/JY5tHqr
<span class="o">[</span>Imgur] JY5tHqr: Downloading webpage
<span class="o">[</span>download] Destination: Imgur-JY5tHqr.mp4
<span class="o">[</span>download] 100% of 190.20KiB <span class="k">in </span>00:01
root@2b927087df24:/# 
</code></pre></div> </div> </li> </ol> <p>Estabelecido um ambiente mínimo para execução da aplicação, o recomendado é gerar um arquivo de instruções base para geração de uma imagem.</p> <div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> ubuntu:18.04</span>

<span class="k">WORKDIR</span><span class="s"> /mydir</span>

<span class="k">RUN </span>apt-get update <span class="o">&amp;&amp;</span> apt-get <span class="nb">install</span> <span class="nt">-y</span> curl python
<span class="k">RUN </span>curl <span class="nt">-L</span> https://yt-dl.org/downloads/latest/youtube-dl <span class="nt">-o</span> /usr/local/bin/youtube-dl
<span class="k">RUN </span><span class="nb">chmod </span>a+x /usr/local/bin/youtube-dl

<span class="k">ENV</span><span class="s"> LC_ALL=C.UTF-8</span>

<span class="c">#CMD ["/usr/local/bin/youtube-dl"]</span>
<span class="k">ENTRYPOINT</span><span class="s"> ["/usr/local/bin/youtube-dl"]</span>
</code></pre></div></div> <p>Todo arquivo <code class="language-plaintext highlighter-rouge">dockerfile</code> deve iniciar com a instrução <code class="language-plaintext highlighter-rouge">FROM</code>, exceto pelo uso da instrução <code class="language-plaintext highlighter-rouge">ARG</code>. <code class="language-plaintext highlighter-rouge">FROM</code> marca um novo estágio da criação da imagem que serve de base para todas as instruções subsequentes. A referência a imagem base, por exemplo, <code class="language-plaintext highlighter-rouge">ubuntu</code>, pode receber uma <em>tag</em>, <em>18.04</em>, ou um <em>digest</em>. <code class="language-plaintext highlighter-rouge">AS &lt;name&gt;</code> pode ser usado para nomear o novo estágio da criação da imagem.</p> <p>A partir do momento em que a instrução <code class="language-plaintext highlighter-rouge">WORKDIR</code> é atribuída, as instruções <code class="language-plaintext highlighter-rouge">RUN</code>, <code class="language-plaintext highlighter-rouge">CMD</code>, <code class="language-plaintext highlighter-rouge">ENTRYPOINT</code>, <code class="language-plaintext highlighter-rouge">COPY</code>, <code class="language-plaintext highlighter-rouge">ADD</code> usam como referência o diretório atribuído a ela. Caso não seja especificado <code class="language-plaintext highlighter-rouge">WORKDIR</code> será <code class="language-plaintext highlighter-rouge">/</code>.</p> <p><code class="language-plaintext highlighter-rouge">RUN</code> executará qualquer comando em uma nova camada sobre a imagem atual e registrará os resultados como uma nova imagem base que servirá de base para as próximas instruções do <code class="language-plaintext highlighter-rouge">dockerfile</code>. Nesse sentido, <code class="language-plaintext highlighter-rouge">RUN</code> é uma instrução que executa em tempo de contrução das imagens, o que é ideal, por exemplo, para incluir pacotes em uma imagem. Há duas formas de se usar a instrução: <code class="language-plaintext highlighter-rouge">RUN &lt;command&gt;</code>, conhecida como formato <code class="language-plaintext highlighter-rouge">shell</code>, ou <code class="language-plaintext highlighter-rouge">RUN</code> <code class="language-plaintext highlighter-rouge">["executable", "param1", "param2"]</code>, conhecida como formato <code class="language-plaintext highlighter-rouge">exec</code>. Esta última exige que se use aspas duplas ao invés de simples, e que se use caracteres de escape como, por exemplo, <code class="language-plaintext highlighter-rouge">RUN ["c:\\windows\\system32\\tasklist.exe"]</code>. Essas exigências surgem porque no formato <em>exec</em> os valores são colocados em um json e tratados. No caso for formato <em>shell</em> é possível utilizar <code class="language-plaintext highlighter-rouge">\</code> para quebra de linhas, tal como no exemplo abaixo.</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RUN /bin/bash <span class="nt">-c</span> <span class="s1">'source $HOME/.bashrc; \
echo $HOME'</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">ENV</code> é uma instrução vinculada a variáveis de ambiente e que uma vez utilizada disponibiliza a variável de ambiente para as instruções subsequentes, mas também para o contêiner, em tempo de execução. Há duas maneiras de utilizar a instrução. A primeira é chamada de estática porque fixa o valor no próprio arquivo de instruções, tal como no exemplo <code class="language-plaintext highlighter-rouge">ENV LC_ALL=C.UTF-8</code>. A segunda maneira é dinâmina, pois permite receber um valor pelo comando que constrói a imagem, tal como no exemplo:</p> <div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">ARG</span><span class="s"> username</span>
<span class="k">ENV</span><span class="s"> env_username $username</span>
</code></pre></div></div> <p>Na versão simplificada de um arquivo de instruções, usamos a instrução <code class="language-plaintext highlighter-rouge">ARG</code> para receber um argumento da chamada do comando <code class="language-plaintext highlighter-rouge">docker build</code> e em seguida ele é atribuído a uma variável de ambiente, que poderá ser utilizada nas próximas instruções ou no contêiner em execução. A chamada do <code class="language-plaintext highlighter-rouge">docker build</code> ficaria assim: <code class="language-plaintext highlighter-rouge">docker build -t exemplo-env-dinamica --build-arg username=docker-user .</code> .</p> <p>Em geral pode-se utilizar quantas instruções <code class="language-plaintext highlighter-rouge">ENV</code> forem necessárias, embora é preciso avaliar que em cada chamada da instrução uma nova camada intermediária será criada.</p> <p>Por fim, <code class="language-plaintext highlighter-rouge">CMD</code> e <code class="language-plaintext highlighter-rouge">ENTRYPOINT</code>. Ambas as instruções permitem definir comandos que serão executados quando o contêiner for executado. <code class="language-plaintext highlighter-rouge">ENTRYPOINT</code> define um executável principal que poderá ser combinado com argumentos recebidos por parâmetro no momento da execução do contêiner, tal como <code class="language-plaintext highlighter-rouge">$ docker run youtube-dl https://imgur.com/JY5tHqr</code>.</p> <p>Por padrão, quando não atribuído um valor específico para <code class="language-plaintext highlighter-rouge">ENTRYPOINT</code> ele recebe <code class="language-plaintext highlighter-rouge">/bin/sh</code>. Por isso quando passamos um comando na execução de um contêiner, o comando é executado.</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker run <span class="nt">-it</span> ubuntu <span class="nb">ls
</span>bin   dev  home  lib32	libx32	mnt  proc  run	 srv  tmp  var
boot  etc  lib	 lib64	media	opt  root  sbin  sys  usr
</code></pre></div></div> <p>Ou ainda quando apenas a instrução <code class="language-plaintext highlighter-rouge">CMD</code> é utilizada com um caminho para um script. Nesse caso, o script é passado como argumento para <code class="language-plaintext highlighter-rouge">/bin/sh</code>.</p> <table> <thead> <tr> <th>dockerfile</th> <th>comando resultado</th> </tr> </thead> <tbody> <tr> <td> <code class="language-plaintext highlighter-rouge">ENTRYPOINT /bin/ping -c 3</code> e <code class="language-plaintext highlighter-rouge">CMD localhost</code> </td> <td><code class="language-plaintext highlighter-rouge">/bin/sh -c '/bin/ping -c 3' /bin/sh -c localhost</code></td> </tr> <tr> <td> <code class="language-plaintext highlighter-rouge">ENTRYPOINT ["/bin/ping","-c","3"]</code> e <code class="language-plaintext highlighter-rouge">CMD localhost</code> </td> <td><code class="language-plaintext highlighter-rouge">/bin/ping -c 3 /bin/sh -c localhost</code></td> </tr> <tr> <td> <code class="language-plaintext highlighter-rouge">ENTRYPOINT /bin/ping -c 3</code> e <code class="language-plaintext highlighter-rouge">CMD ["localhost"]</code> </td> <td><code class="language-plaintext highlighter-rouge">/bin/sh -c '/bin/ping -c 3' localhost</code></td> </tr> <tr> <td> <code class="language-plaintext highlighter-rouge">ENTRYPOINT ["/bin/ping","-c","3"]</code> e <code class="language-plaintext highlighter-rouge">CMD ["localhost"]</code> </td> <td><code class="language-plaintext highlighter-rouge">/bin/ping -c 3 localhost</code></td> </tr> </tbody> </table> <p><code class="language-plaintext highlighter-rouge">ENTRYPOINT</code> terá sempre um valor fixo nos contêineres executados a partir de uma mesma imagem. No entanto, em cada execução <code class="language-plaintext highlighter-rouge">docker run</code> é possível passar diferentes argumentos que funcionam como <code class="language-plaintext highlighter-rouge">CMD</code>, mesmo que ele esteja atribuído no dockerfile, o parâmetro passado na chamada do <code class="language-plaintext highlighter-rouge">docker run</code> o sobreescreverá.</p> <p><a href="#introdu%C3%A7%C3%A3o">⇡</a></p> <h3 id="usando-volume-e-portas-para-interagir-com-contêineres">Usando volume e portas para interagir com contêineres</h3> <p>Embora um contêiner seja uma unidade isolada, existe uma série de maneiras de interagir com ele. Nesta seção analizaremos duas maneiras: volume e portas.</p> <p>A imagem que criamos na seção anterior tem como finalidade isolar uma aplicação de download de videos. Seria interessante, então, que o usuário no host conseguisse acessar os vídeos de modo simples. Uma forma de viabilizar isso é ligar um volume externo com um volume interno.</p> <p>A técnica é chamada de <em>bind mount</em> e é feita pelo comando <em>docker run</em>: <code class="language-plaintext highlighter-rouge">docker run -v "$(pwd):/mydir" youtube-dl https://imgur.com/JY5tHqr</code>. Ademais, esssa ténica pode ser usada para conectar contêineres que precisam compartilhar arquivos entre si.</p> <p>Outra estratégia é compartilhar um arquivo específico, por exemplo, um arquivo de configurações: <code class="language-plaintext highlighter-rouge">-v $(pwd)/config.file:/mydir/config.file</code>. Com isso, modificações no arquivo a partir do host refletem no contêiner.</p> <p><a href="#introdu%C3%A7%C3%A3o">⇡</a></p> <h3 id="permitindo-conexões-externas-com-contêineres">Permitindo conexões externas com contêineres</h3> <p>A segunda técnica é chamada de <em>port bind</em> e é muito utilizada para disponibilizar serviços que estão executando no contêiner para acesso externo, enviando ou recebendo mensagens para endereços <em>url</em> tal como <code class="language-plaintext highlighter-rouge">http://127.0.0.1:4000</code>. Isso é possível através de um mapeamento entre uma porta do computador host e uma porta do contêiner. A abertura de uma porta do lado de fora para o contêiner acontece em dois passos:</p> <ol> <li>exposição de porta (exposing port);</li> <li>publicação de porta (publishing port).</li> </ol> <p>Exposição de porta indica que o contêiner passa a <em>escutar</em> em uma determinada porta e para isso utiliza a instrução <code class="language-plaintext highlighter-rouge">EXPOSE &lt;porta&gt;</code> no <code class="language-plaintext highlighter-rouge">dockerfile</code>. Publicar uma porta indica ao <em>docker</em> para mapear portas do host para as portas do contêiner e é feito ao executar o contêiner: <code class="language-plaintext highlighter-rouge">-p &lt;host-porta&gt;:&lt;container-porta&gt;</code>.</p> <p>Também é possível limitar as conexões para certo protocolo: <code class="language-plaintext highlighter-rouge">EXPOSE &lt;porta&gt;/udp</code> e <code class="language-plaintext highlighter-rouge">-p &lt;host-porta&gt;:&lt;container-porta&gt;/udp</code>.</p> <p>Expor portas é uma questão crítica na segurança de ambientes e o modo como isso é feito pode ocasionar que qualquer um tenha acesso à porta exposta. Uma forma de reduzir a área de exposição é forçar que a ligação seja feita apenas com um host específico, tal como: <code class="language-plaintext highlighter-rouge">-p 127.0.0.1:33456:4000</code>. Assim, apenas conexões do localhost podem ser feitas. Menos recomendado é <code class="language-plaintext highlighter-rouge">-p 3456:3000</code>, que é igual a <code class="language-plaintext highlighter-rouge">-p 0.0.0.0:33456:4000</code>, significando que a porta <code class="language-plaintext highlighter-rouge">4000</code> está aberta para qualquer um.</p> <p><a href="#introdu%C3%A7%C3%A3o">⇡</a></p> <h2 id="exercícios">Exercícios</h2> <h3 id="execício-1">Execício 1</h3> <p>Testar a instalação e a permissão do <code class="language-plaintext highlighter-rouge">docker</code> usando imagem teste <code class="language-plaintext highlighter-rouge">hello-world</code>. Primeiro usando o comando <code class="language-plaintext highlighter-rouge">docker run</code>.</p> <details> <summary>Comandos</summary> <figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="nv">$ </span>docker run hello-world</code></pre></figure> </details> <p><br></p> <p>Caso não ocorra problemas na execução, esse contêiner imprime na tela a frase <em>Hello from Docker!</em> com uma explicação de como essa mensagem foi gerada usando o <code class="language-plaintext highlighter-rouge">docker</code>. No entanto, o comando <code class="language-plaintext highlighter-rouge">docker run</code> é uma simplificação de alguns outros comandos. Antes de executar cada um dos comandos na ordem correta para executar o contêiner, vamos remover os objetos criados por <code class="language-plaintext highlighter-rouge">docker run hello-world</code>.</p> <p>Respeitando a ordem de dependências, remova contêineres dependetes da imagem <code class="language-plaintext highlighter-rouge">hello-world</code>, em seguida a imagem.</p> <details> <summary>Comandos</summary> <figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="nv">$ </span>docker ps <span class="nt">-a</span> <span class="c"># listar o contêiner para obter o id</span>
<span class="nv">$ </span>docker <span class="nb">rm</span> &lt;contêiner-id&gt;
<span class="nv">$ </span>docker rmi hello-world</code></pre></figure> </details> <p><br></p> <p>Executar na ordem correta os comandos utilizados pelo comando <code class="language-plaintext highlighter-rouge">docker run</code>, para executar um contêiner baseado na imagem <code class="language-plaintext highlighter-rouge">hello-world</code>.</p> <details> <summary>Comandos</summary> <figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="nv">$ </span>docker images hello-world <span class="c"># verificar se a imagem existe localmente. </span>
<span class="nv">$ </span>docker search hello-world <span class="c"># como removemos a imagem local, procurar no docker hub.</span>
<span class="nv">$ </span>docker pull hello-world 
<span class="nv">$ </span>docker create hello-world
<span class="nv">$ </span>docker ps <span class="nt">-a</span> <span class="c"># listar o contêiner criado</span>
<span class="nv">$ </span>docker start <span class="nt">-i</span> &lt;contêiner-id&gt;</code></pre></figure> </details> <p><br></p> <p>Utilizando os comandos separadamente, o rasultado deve ser o mesmo. Por fim, remova os objetivos criados.</p> <details> <summary>Comandos</summary> <figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="nv">$ </span>docker ps <span class="nt">-a</span> <span class="c"># listar o contêiner para obter o id</span>
<span class="nv">$ </span>docker <span class="nb">rm</span> &lt;contêiner-id&gt;
<span class="nv">$ </span>docker rmi hello-world</code></pre></figure> </details> <p><br></p> <h3 id="exercício-2">Exercício 2</h3> <p><code class="language-plaintext highlighter-rouge">Alpine</code> é uma das mais leves distribuições do <code class="language-plaintext highlighter-rouge">Linux</code> e por isso tornou-se uma das mais populares distribuições usadas em imagens para o <code class="language-plaintext highlighter-rouge">docker</code>, como suporte para outras imagens. Primeiro, vamos verificar se a imagem <code class="language-plaintext highlighter-rouge">alpine</code> existe localmente e no repositório remoto.</p> <details> <summary>Comandos</summary> <figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="nv">$ </span>docker images alpine <span class="c"># verficar se a imagem já está disponível localmente.</span>
<span class="nv">$ </span>docker search alpine <span class="c"># verficar se a imagem está disponível para download no repositório remoto.</span></code></pre></figure> </details> <p><br></p> <p>Agora vamos obter a imagem <code class="language-plaintext highlighter-rouge">alpine</code>, isto é, fazer o download dela do repositório remoto para o local, deixando-a disponível para criação de contêineres. E verficar se ela está disponível localmente.</p> <details> <summary>Comandos</summary> <figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="nv">$ </span>docker image pull alpine 
<span class="nv">$ </span>docker image <span class="nb">ls</span> | <span class="nb">grep </span>alpine</code></pre></figure> </details> <p><br></p> <p>Com a imagem disponível localmente, é possível instanciar contêineres baseados nela. Vamos executar um contêiner baseado na imagem <code class="language-plaintext highlighter-rouge">alpine</code> e solicitar que seja executado no contêiner o comando <code class="language-plaintext highlighter-rouge">ls -l</code>.</p> <details> <summary>Comandos</summary> <figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="nv">$ </span>docker container run alpine <span class="nb">ls</span> <span class="nt">-l</span></code></pre></figure> </details> <p><br></p> <p>O comando <code class="language-plaintext highlighter-rouge">docker run</code> cria uma instância de um contêiner baseado na imagem <code class="language-plaintext highlighter-rouge">alpine</code> e executa dentro do contêiner o comando <code class="language-plaintext highlighter-rouge">ls -l</code>. O resultado do comando é devolvido para o terminal que solicitou, imprimindo na tela. Não é necessário utilizar as <em>flags</em> <code class="language-plaintext highlighter-rouge">-it</code> porque por padrão o docker conecta o <em>sdtout</em> do contêiner com o terminal que solicitou a execução. Como já é conhecido, depois da execução do comando no contêiner, o contêiner se encerra porque a sua função foi concluída.</p> <p>Execute um contêiner baseado na imagem <code class="language-plaintext highlighter-rouge">alpine</code> e solicite que seja executado o comando <code class="language-plaintext highlighter-rouge">echo "olá do contêiner alpine"</code> no contêiner.</p> <details> <summary>Comandos</summary> <figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="nv">$ </span>docker container run alpine <span class="nb">echo</span> <span class="s2">"olá do contêiner alpine"</span></code></pre></figure> </details> <p><br></p> <p>Agora, rode o comando <code class="language-plaintext highlighter-rouge">/bin/sh</code> no contêiner.</p> <details> <summary>Comandos</summary> <figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="nv">$ </span>docker container run alpine /bin/sh</code></pre></figure> </details> <p><br></p> <p>Nas duas primeiras execuções, os comandos <code class="language-plaintext highlighter-rouge">ls -l</code> e <code class="language-plaintext highlighter-rouge">echo "olá do contêiner alpine"</code> são executados e o retorno de cada um retornado para o terminal que os executou. No último caso, o comando <code class="language-plaintext highlighter-rouge">/bin/sh</code> executa sem nenhum retorno porque o comando deveria abrir um terminal. No entanto, ao executar <code class="language-plaintext highlighter-rouge">docker run</code> não foi vinculado um terminal de entrada e saída.</p> <p>Execute o comando <code class="language-plaintext highlighter-rouge">docker run</code> com shell interativo.</p> <details> <summary>Comandos</summary> <figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="nv">$ </span>docker container run <span class="nt">-it</span> alpine /bin/sh</code></pre></figure> </details> <p><br></p> <p>Como comparação, máquinas virtuais emulam todo uma pilha de hardware, boot e sistema operacional para então executar algum programa ou função específica. <code class="language-plaintext highlighter-rouge">Docker</code> funciona diretamente em nível de aplicação, tornando-o mais dinâmico no ciclo de criação e destrução de contêineres.</p> <p>Visualize os contêineres executados até agora.</p> <details> <summary>Comandos</summary> <figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="nv">$ </span>docker container <span class="nb">ls</span> <span class="nt">-a</span> <span class="c"># versão completa.</span>
<span class="nv">$ </span>docker ps <span class="nt">-a</span> <span class="c"># versão simplificada.</span></code></pre></figure> </details> <p><br></p> <h3 id="exercício-3">Exercício 3</h3> <p>Uma das características mais importantes da contêinerização com docker é o isolamento dos contêineres. Cada contêiner tem um sistema de arquivos separado e executa em um <em>namespace</em> diferente. Por padrão, os contêineres não interagem entre si, mesmo que utilizem a mesma imagem.</p> <p>Execute um contêiner usando a imagem <code class="language-plaintext highlighter-rouge">alpine</code>, com shell interativo e solicite a execução do comando <code class="language-plaintext highlighter-rouge">/bin/ash</code>. Ao iniciar o contêiner, crie um arquivo chamado <code class="language-plaintext highlighter-rouge">isolamento.txt</code> com o conteúdo <em>contêiner isolado</em>.</p> <details> <summary>Comandos</summary> <figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="nv">$ </span>docker container run <span class="nt">-it</span> alpine /bin/ash
/ <span class="c"># echo "contêiner isolado" &gt; isolamento.txt</span>
/ <span class="c"># ls -l isolamento.txt</span></code></pre></figure> </details> <p><br></p> <p>Em um outro terminal, crie um contêiner baseado na imagem <code class="language-plaintext highlighter-rouge">alpine</code> e solicite a execução do comando <code class="language-plaintext highlighter-rouge">ls</code></p> <details> <summary>Comandos</summary> <figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="nv">$ </span>docker container run alpine <span class="nb">ls</span></code></pre></figure> </details> <p><br></p> <p>Como esperado, na execução do segundo contêiner o arquivo <code class="language-plaintext highlighter-rouge">isolamento.txt</code> não é listado. Isso é o isolamento dos contêineres e uma das principais características de segurança do <code class="language-plaintext highlighter-rouge">docker</code>. No entanto, no dia-a-dia isolamento permite com que usuários rapidamente criem cópias de teste de aplicações separadas, isoladas e rodando lado a lado sem interferência.</p> <h3 id="exercício-4">Exercício 4</h3> <p>Os exercícios anteriores criaram muitos objetos. Remova os contêineres e as imagens usadas acima.</p> <details> <summary>Comandos</summary> <figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="nv">$ </span>docker container prune
<span class="nv">$ </span>docker rmi alpine
<span class="nv">$ </span>docker rmi hello-world</code></pre></figure> </details> <p><br></p> <h3 id="exercício-5">Exercício 5</h3> <p>Use a imagem <code class="language-plaintext highlighter-rouge">devopsdockeruh/simple-web-service:ubuntu</code> para criar um contêiner. Acesse o contêiner pelo terminal e leia o arquivo <code class="language-plaintext highlighter-rouge">./text.log</code>.</p> <details> <summary>Comandos</summary> <figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="c"># O contêiner será executado desvinculado (-d) do terminal, </span>
<span class="c"># mas com a possibilidade de vinculação (-it). </span>
<span class="c"># O nome dele será fixo --name log-webserver</span>
<span class="nv">$ </span>docker container run <span class="nt">-d</span> <span class="nt">-it</span> <span class="nt">--name</span> log-webserver devopsdockeruh/simple-web-service:ubuntu
<span class="c">#</span>
<span class="c"># verifica se o contêiner foi criado corretamente.</span>
<span class="nv">$ </span>docker ps | <span class="nb">grep </span>log-webserver
<span class="c">#</span>
<span class="c"># podemos verificar se o contêiner está rodando o programa principal dele `/usr/src/app/server`.</span>
<span class="c"># `--no-stdin` não vincula o stream de entrada de dados ao terminal que executou o comando.</span>
<span class="c"># apenas é vinculado o stdout. Com isso, podemos usar o comando `ctrl+c` para encerrar</span>
<span class="c"># a visualização do stream de saída sem interromper o contêiner. </span>
<span class="c"># Outra opção, sem usar `--no-stdin`, é a sequência `ctrl+p` e `ctrl+q`</span>
<span class="nv">$ </span>docker attach <span class="nt">--no-stdin</span> log-webserver
<span class="c">#</span>
<span class="c"># mas o objetivo é acessar outro arquivo `./text.log`.</span>
<span class="c"># É preciso acessar o sistema de arquivos do contêiner.</span>
<span class="nv">$ </span>docker <span class="nb">exec</span> <span class="nt">-it</span> log-webserver bash
<span class="c">#</span>
<span class="c"># acessado o ambiente do contêiner, basta ler o arquivo.</span>
root@df1404fa4f3a:/usr/src/app# <span class="nb">tail</span> <span class="nt">-f</span> ./text.log</code></pre></figure> </details> <p><br></p> <p>Esta imagem <code class="language-plaintext highlighter-rouge">devopsdockeruh/simple-web-service:alpine</code> tem a mesma função que a anterior, embora seja baseada em <code class="language-plaintext highlighter-rouge">alpine</code>. Faça download e compare os tamanhos entre elas. <code class="language-plaintext highlighter-rouge">Alpine</code> é uma das mais enxutas imagens com linux. Em seguida, faça a mesma tarefa designada acima.</p> <details> <summary>Comandos</summary> <figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="c">#</span>
<span class="c"># primeiro fazer o download da nova imagem.</span>
<span class="nv">$ </span>docker image pull devopsdockeruh/simple-web-service:alpine
<span class="c">#</span>
<span class="c"># agora vamos listar as imagens e comparar os tamanhos. Como dissemos, a versão `alpine` é consideravelmente mais leve.</span>
<span class="c">#</span>
<span class="nv">$ </span>docker images | <span class="nb">grep </span>devopsdockeruh
<span class="c"># agora podemos seguir os passos utilizados na primeira imagem.</span>
<span class="c"># O contêiner será executado desvinculado (-d) do terminal, </span>
<span class="c"># mas com a possibilidade de vinculação (-it). </span>
<span class="c"># O nome dele será fixo --name log-webserver-alp</span>
<span class="nv">$ </span>docker container run <span class="nt">-d</span> <span class="nt">-it</span> <span class="nt">--name</span> log-webserver-alp devopsdockeruh/simple-web-service:alpine
<span class="c">#</span>
<span class="c"># verifica se o contêiner foi criado corretamente.</span>
<span class="nv">$ </span>docker ps | <span class="nb">grep </span>log-webserver-alp
<span class="c">#</span>
<span class="c"># podemos verificar se o contêiner está rodando o programa principal dele `/usr/src/app/server`.</span>
<span class="c"># `--no-stdin` não vincula o stream de entrada de dados ao terminal que executou o comando.</span>
<span class="c"># apenas é vinculado o stdout. Com isso, podemos usar o comando `ctrl+c` para encerrar</span>
<span class="c"># a visualização do stream de saída sem interromper o contêiner. </span>
<span class="c"># Outra opção, sem usar `--no-stdin`, é a sequência `ctrl+p` e `ctrl+q`</span>
<span class="nv">$ </span>docker attach <span class="nt">--no-stdin</span> log-webserver-alp
<span class="c">#</span>
<span class="c"># mas o objetivo é acessar outro arquivo `./text.log`.</span>
<span class="c"># É preciso acessar o sistema de arquivos do contêiner.</span>
<span class="nv">$ </span>docker <span class="nb">exec</span> <span class="nt">-it</span> log-webserver-alp bash
<span class="c">#</span>
<span class="c"># acessado o ambiente do contêiner, basta ler o arquivo.</span>
root@df1404fa4f3a:/usr/src/app# <span class="nb">tail</span> <span class="nt">-f</span> ./text.log</code></pre></figure> </details> <p><br></p> <h3 id="exercício-6">Exercício 6</h3> <p>Instanciar um contêiner baseado em uma imagem <code class="language-plaintext highlighter-rouge">ubuntu</code>, passando como argumento <code class="language-plaintext highlighter-rouge">sh -c 'echo "Input website:"; read website; echo "Searching.."; sleep 1; curl http://$website;'</code>. Entre as aspas estão vários comandos de terminal. Dentre eles: <code class="language-plaintext highlighter-rouge">read website</code> e <code class="language-plaintext highlighter-rouge">curl http://$website;</code>.</p> <p>O objetivo é fazer com que a instância do contêiner interaja com o usuário no terminal que executou o comando <code class="language-plaintext highlighter-rouge">docker run</code>, pedindo uma url que será lida pelo comando <code class="language-plaintext highlighter-rouge">read</code>, atribuída a uma variável de ambiente <code class="language-plaintext highlighter-rouge">website</code> e utilizada no comando <code class="language-plaintext highlighter-rouge">curl</code>.</p> <details> <summary>Comandos</summary> <figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="c">#</span>
<span class="c"># ao invés de utilizar o comando run diretamente, primeiro vamos verificar se existe uma imagem ubuntu local.</span>
<span class="nv">$ </span>docker images ubuntu
<span class="c">#</span>
<span class="c"># considerando que o comando acima retorne vazio, vamos procurar por uma imagem no repositório remoto do docker</span>
<span class="nv">$ </span>docker search ubuntu
<span class="c">#</span>
<span class="c"># esse comando deve retornar várias linhas. entre essas, a primeira deve indicar a imagem oficial do ubuntu, chamada `ubuntu`. </span>
<span class="c"># vamos fazer o download dessa imagem.</span>
<span class="c">#</span>
<span class="nv">$ </span>docker image pull ubuntu
<span class="c">#</span>
<span class="c"># feito isso, precisamos modificar o comando  'echo "Input website:"; read website; echo "Searching.."; sleep 1; curl http://$website;'` para que ele solicite a instalação do `curl` e a chamada do comando `docker run` passando uma variável de ambiente. Além disso, `-it` deve ser incluído para que o contêiner interaja com o terminal.</span>
<span class="c">#</span>
<span class="nv">$ </span>docker container run <span class="nt">-it</span> <span class="nt">--env</span> website ubuntu sh <span class="nt">-c</span> <span class="s1">'apt update &amp;&amp; apt upgrade -y &amp;&amp; apt install curl -y;echo "Input website:"; read website; echo $website; curl $website;'</span></code></pre></figure> </details> <p><br></p> <p>Importante limpar os objetos criados após atingir o objetivo do exercício.</p> <details> <summary>Comandos</summary> <figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="nv">$ </span>docker container prune</code></pre></figure> </details> <p><br></p> <p><a href="#introdu%C3%A7%C3%A3o">⇡</a></p> <h3 id="exercício-7">Exercício 7</h3> <p>Neste exercício usaremos a imagem <code class="language-plaintext highlighter-rouge">devopsdockeruh/pull_exercise</code>. O programa principal que roda nela solicita que o usuário informe uma senha no terminal. A senha está em um arquivo no sistema de arquivos do contêiner.</p> <details> <summary>Comandos</summary> <figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="c">#</span>
<span class="c"># como precisamos interagir com o contêiner, a execução precisa das *frags* `-it`.</span>
<span class="nv">$ </span>docker run <span class="nt">-it</span> <span class="nt">--name</span><span class="o">=</span>pull-exercise devopsdockeruh/pull_exercise
<span class="c">#</span>
<span class="c"># feito isso, o terminal mostrará a mensagem "Give me the password: ".</span>
<span class="c">#</span>
<span class="c"># para descobrir a senha, precisar acessar o contêiner por um outro terminal. Essa imagem não possui o `bash`, precisamos usar `sh`.</span>
<span class="nv">$ </span>docker <span class="nb">exec</span> <span class="nt">-it</span> pull-exercise sh
<span class="c">#</span>
<span class="c"># por onde começamos a procurar? o comando padrão que está executando na imagem pode ser visto utilizado `docker ps`</span>
<span class="nv">$ </span>docker ps
<span class="c">#</span>
<span class="c"># sabemos agora que a imagem roda `node index.js`. analisando o arquivo `index.js`</span>
<span class="nv">$ </span><span class="nb">cat</span> /usr/app/index.js
<span class="c">#</span>
<span class="c"># no código, a senha correta é "basics".</span></code></pre></figure> </details> <p><br></p> <h3 id="exercício-8">Exercício 8</h3> <p>Baseado na imagem <code class="language-plaintext highlighter-rouge">devopsdockeruh/simple-web-service:alpine</code> construa outra imagem chamada <code class="language-plaintext highlighter-rouge">web-server</code> que rode o servidor web (/usr/src/app/server). Ao fim, o servidor deve iniciar quando for executado <code class="language-plaintext highlighter-rouge">docker run web-server</code>.</p> <details> <summary>Comandos</summary> <figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="c">#</span>
<span class="c"># há dois modos para se criar uma imagem: modificar um contêiner e a partir do contêiner criar uma imagem, </span>
<span class="c"># criar um arquivo `Dockerfile` como base. Neste exercício vamos usar um Dockerfile.</span>
<span class="c"># O arquivo irá usar duas instruções `FROM` e `CMD`. Com a instrução `FROM` vinculamos a nova imagem a base, na qual está o web-server.</span>
<span class="c"># Com a instrução `CMD`, indicamos qual programa irá executar quando o contêiner for iniciado.</span>
<span class="c">#</span>
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"FROM devopsdockeruh/simple-web-service"</span> <span class="o">&gt;</span> web-server-dockerfile
<span class="nv">$ </span><span class="nb">echo</span> <span class="o">&gt;&gt;</span> web-server-dockerfile 
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"CMD server"</span> <span class="o">&gt;&gt;</span> web-server-dockerfile
<span class="c">#</span>
<span class="c"># confirmar que o arquivo foi gerado.</span>
<span class="nv">$ </span><span class="nb">cat </span>web-server-dockerfile
<span class="c">#</span>
<span class="c"># construir a imagem com a *tag* `web-server:latest`, usando o arquivo web-server-dockerfile.</span>
<span class="nv">$ </span>docker build <span class="nt">-t</span> web-server <span class="nt">-f</span> web-server-dockerfile <span class="nb">.</span>
<span class="c">#</span>
<span class="c"># executar o servidor web passado como argumento na chamado do docker run.</span>
<span class="nv">$ </span>docker run web-server</code></pre></figure> </details> <p><br></p> <h3 id="exercício-9">Exercício 9</h3> <p><a href="#exerc%C3%ADcio-6">No exercício 6</a> passamos os comandos <code class="language-plaintext highlighter-rouge">echo "Input website:"; read website; echo "Searching.."; sleep 1; curl http://$website;</code> para um contêiner através do comando <code class="language-plaintext highlighter-rouge">docker run</code>. O objetivo, agora, é criar um Dockerfile baseado na imagem <code class="language-plaintext highlighter-rouge">ubuntu:20.04</code>, com as dependências instaladas para rodar a <em>string</em> de comandos acima. Esses comandos devem estar em um script, <code class="language-plaintext highlighter-rouge">.sh</code>, que deve ser copiado para a imagem e executado usando a instrução <code class="language-plaintext highlighter-rouge">CMD</code>.</p> <details> <summary>Comandos</summary> <figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="c">#</span>
<span class="c"># primeira parte, criar arquivo curler.sh com o conteúdo `echo "Input website:"; read website; echo "Searching.."; sleep 1; curl http://$website;`.</span>
<span class="nv">$ </span><span class="nb">touch </span>curler.sh
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"#!/bin/bash"</span> <span class="o">&gt;</span> curler.sh
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"echo 'Input website:'"</span> <span class="o">&gt;&gt;</span> curler.sh
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"read website"</span> <span class="o">&gt;&gt;</span> curler.sh
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"echo 'Searching..'"</span> <span class="o">&gt;&gt;</span> curler.sh
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"sleep 1"</span> <span class="o">&gt;&gt;</span> curler.sh
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"curl http://</span><span class="nv">$website</span><span class="s2">"</span> <span class="o">&gt;&gt;</span> curler.sh
<span class="c">#</span>
<span class="c"># criar o arquivo curler-dockerfile.</span>
<span class="nv">$ </span><span class="nb">touch </span>curler-dockerfile
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"FROM ubuntu:20.04"</span> <span class="o">&gt;</span> curler-dockerfile
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"RUN apt update &amp;&amp; apt upgrade -y &amp;&amp; apt install curl -y"</span> <span class="o">&gt;&gt;</span> curler-dockerfile
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"COPY ./curler.sh"</span> <span class="o">&gt;&gt;</span> curler-dockerfile
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"RUN chmod +x curler.sh"</span> <span class="o">&gt;&gt;</span> curler-dockerfile
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"CMD /curler.sh"</span> <span class="o">&gt;&gt;</span> curler-dockerfile
<span class="c">#</span>
<span class="c"># montar a imagem com a tag curler</span>
<span class="nv">$ </span>docker build <span class="nt">-t</span> curler <span class="nt">-f</span> curler-dockerfile <span class="nb">.</span>
<span class="nv">$ </span>docker run <span class="nt">-it</span> curler</code></pre></figure> </details> <p><br></p> <h3 id="exercício-10">Exercício 10</h3> <p><a href="#exerc%C3%ADcio-9">No exercício 9</a> usamos a instrução <code class="language-plaintext highlighter-rouge">CMD</code> para rodar o comando <code class="language-plaintext highlighter-rouge">curl</code>. Com essa abordagem, o script torna-se responsável por solicitar a url. Se utilizarmos a instrução <code class="language-plaintext highlighter-rouge">ENTRYPOINT</code> para rodar o comando <code class="language-plaintext highlighter-rouge">curl</code>, podemos passar a url quando rodamos o comando <code class="language-plaintext highlighter-rouge">docker run</code>.</p> <details> <summary>Comandos</summary> <figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="c">#</span>
<span class="c"># primeiro vamos modificar o script. A modificação permite que passemos parâmetro na execução do script.</span>
<span class="nv">$ </span><span class="nb">touch </span>curler.sh
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"#!/bin/bash"</span> <span class="o">&gt;</span> curler.sh
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"echo 'Searching..'"</span> <span class="o">&gt;&gt;</span> curler.sh
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"sleep 1"</span> <span class="o">&gt;&gt;</span> curler.sh
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"curl http://</span><span class="nv">$1</span><span class="s2">"</span> <span class="o">&gt;&gt;</span> curler.sh
<span class="c">#</span>
<span class="c"># criar o arquivo curler-dockerfile.</span>
<span class="nv">$ </span><span class="nb">touch </span>curler-dockerfile-v2
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"FROM ubuntu:20.04"</span> <span class="o">&gt;</span> curler-dockerfile-v2
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"RUN apt update &amp;&amp; apt upgrade -y &amp;&amp; apt install curl -y"</span> <span class="o">&gt;&gt;</span> curler-dockerfile-v2
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"COPY ./curler.sh"</span> <span class="o">&gt;&gt;</span> curler-dockerfile-v2
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"RUN chmod +x curler.sh"</span> <span class="o">&gt;&gt;</span> curler-dockerfile-v2
<span class="nv">$ </span><span class="nb">echo</span> <span class="s1">'ENTRYPOINT ["/curler.sh"]'</span> <span class="o">&gt;&gt;</span> curler-dockerfile-v2
<span class="c">#</span>
<span class="c"># montar a imagem com a tag curler</span>
<span class="nv">$ </span>docker build <span class="nt">-t</span> curler-v2 <span class="nt">-f</span> curler-dockerfile-v2 <span class="nb">.</span>
<span class="nv">$ </span>docker run curler-v2 google.com</code></pre></figure> </details> <p><br></p> <h3 id="exercício-11">Exercício 11</h3> <p>Neste exercício, usaremos a ligação de volume para conectar um arquivo local com um arquivo no contêiner. A imagem utilizada para criação do contêiner é <code class="language-plaintext highlighter-rouge">devopsdockeruh/simple-web-service</code>. O arquivo no contêiner é gerado como um <code class="language-plaintext highlighter-rouge">log</code>. Deve-se utilizar a <em>flag</em> <code class="language-plaintext highlighter-rouge">-v</code>.</p> <details> <summary>Comandos</summary> <figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="c">#</span>
<span class="c"># no diretório corrente vamos criar um arquivo</span>
<span class="nv">$ </span><span class="nb">touch </span>text.log
<span class="c"># agora vamos rodar um contêiner</span>
<span class="nv">$ </span>docker run <span class="nt">-v</span> <span class="s2">"</span><span class="si">$(</span><span class="nb">pwd</span><span class="si">)</span><span class="s2">/text.log:/usr/src/app/text.log"</span> devopsdockeruh/simple-web-service</code></pre></figure> </details> <p><br></p> <h3 id="exercício-12">Exercício 12</h3> <p>Neste exercício, usaremos a ligação de portas para conectar o host ao servidor web no contêiner. A imagem que deve ser utilizada é <code class="language-plaintext highlighter-rouge">devopsdockeruh/simple-web-service</code>. Nessa imagem, quando o comando <code class="language-plaintext highlighter-rouge">server</code> é passado para o comando <code class="language-plaintext highlighter-rouge">docker run</code> um servidor web é inicializado na porta 8080. No host, a porta de ligação fica a sua escolha.</p> <details> <summary>Comandos</summary> <figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="c">#</span>
<span class="c"># comando básico</span>
<span class="nv">$ </span>docker run <span class="nt">-p8082</span>:8080 devopsdockeruh/simple-web-service server</code></pre></figure> </details> <p><br></p> <h3 id="exercício-13">Exercício 13</h3> <p>Neste exercício usaremos a aplicação <a href="https://github.com/pFransozi/docker-hy-material-applications/tree/main/spring-example-project" rel="external nofollow noopener" target="_blank">spring-example-project</a> e a colocaremos em um contêiner que use a imagem <code class="language-plaintext highlighter-rouge">openjdk:_tag_</code>. Um <code class="language-plaintext highlighter-rouge">dockerfile</code> deve ser criado que copie os arquivos fontes da aplicação para a imagem e compile-os na imagem. Ao iniciar um contêiner baseado nessa imagem, deve ser possível passar o comando <code class="language-plaintext highlighter-rouge">java -jar ./target/docker-example-1.1.3.jar</code> ao <code class="language-plaintext highlighter-rouge">docker run</code> para iniciar a aplicação. Essa aplicação deve ser acessada pelo host usando uma ligação de porta.</p> <details> <summary>Comandos</summary> <figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="c">#</span>
<span class="c"># primeiro deve-se clonar o projeto `spring-example-project` localmente.</span>
<span class="nv">$ </span>git clone git@github.com:pFransozi/docker-hy-material-applications.git
<span class="c">#</span>
<span class="c"># acessar o diretório da aplicação</span>
<span class="nv">$ </span><span class="nb">cd </span>spring-example-project
<span class="c">#</span>
<span class="c"># criar um `dockerfile`</span>
<span class="nv">$ </span><span class="nb">touch </span>spring-example-project-dockerfile
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"FROM openjdk:21-jdk-oraclelinux8"</span> <span class="o">&gt;</span> spring-example-project-dockerfile
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"COPY . /usr/src/myapp"</span> <span class="o">&gt;&gt;</span> spring-example-project-dockerfile
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"WORKDIR /usr/src/myapp"</span> <span class="o">&gt;&gt;</span> spring-example-project-dockerfile
<span class="c"># compila a aplicação e a disponibiliza compilada na imagem.</span>
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"RUN ./mvnw package"</span> <span class="o">&gt;&gt;</span> spring-example-project-dockerfile
<span class="c"># com isso, podemos iniciar um contêiner já rodando a aplicação</span>
<span class="nv">$ </span><span class="nb">echo</span> <span class="s1">'ENTRYPOINT ["java"]'</span> <span class="o">&gt;&gt;</span> spring-example-project-dockerfile
<span class="c">#</span>
<span class="c"># compilar uma imagem</span>
<span class="nv">$ </span>docker build <span class="nt">-t</span> app-spring:v1 <span class="nt">-f</span> spring-example-project-dockerfile <span class="nb">.</span>
<span class="nv">$ </span>docker run <span class="nt">-it</span> <span class="nt">-p8082</span>:8080 app-spring:v1 <span class="nt">-jar</span> ./target/docker-example-1.1.3.jar</code></pre></figure> </details> <p><br></p> <h3 id="exercício-14">Exercício 14</h3> <p>Criar uma imagem baseada na imagem <code class="language-plaintext highlighter-rouge">node:16.16.0-alpine3.16</code> que atenda os requisitos <a href="https://github.com/pFransozi/docker-hy-material-applications/tree/main/example-frontend" rel="external nofollow noopener" target="_blank">deste projeto</a>.</p> <details> <summary>Comandos</summary> <figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="c"># primeiro deve-se clonar o projeto `spring-example-project` localmente.</span>
<span class="nv">$ </span>git clone git@github.com:pFransozi/docker-hy-material-applications.git
<span class="c">#</span>
<span class="c"># acessar o diretório do arquivo fonte.</span>
<span class="nv">$ </span><span class="nb">cd </span>example-frontend
<span class="c">#</span>
<span class="c"># criar arquivo `dockerfile`</span>
<span class="nv">$ </span><span class="nb">touch </span>ex-frontend-dockerfile
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"FROM node:16.16.0-alpine3.16"</span> <span class="o">&gt;</span> ex-frontend-dockerfile
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"COPY . /usr/src/myapp"</span> <span class="o">&gt;&gt;</span> ex-frontend-dockerfile
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"WORKDIR /usr/src/myapp"</span> <span class="o">&gt;&gt;</span> ex-frontend-dockerfile
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"RUN npm install package.json"</span> <span class="o">&gt;&gt;</span> ex-frontend-dockerfile
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"RUN npm run build"</span> <span class="o">&gt;&gt;</span> ex-frontend-dockerfile
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"RUN npm install -g serve"</span> <span class="o">&gt;&gt;</span> ex-frontend-dockerfile
<span class="c">#</span>
<span class="c">#</span>
<span class="nv">$ </span>docker build <span class="nt">-t</span> ex-frontend:v1 <span class="nt">-f</span> ex-frontend-dockerfile <span class="nb">.</span>
<span class="c">#</span>
<span class="c">#</span>
docker run <span class="nt">-it</span> <span class="nt">-p5001</span>:5000 ex-frontend:v1 serve <span class="nt">-s</span> <span class="nt">-l</span> 5000 build</code></pre></figure> </details> <p><br></p> <h3 id="exercício-15">Exercício 15</h3> <p>Criar uma imagem a partir da imagem <code class="language-plaintext highlighter-rouge">golang</code> que atenda os requisitos do <a href="https://github.com/pFransozi/docker-hy-material-applications/tree/main/example-backend" rel="external nofollow noopener" target="_blank">projeto</a>.</p> <details> <summary>Comandos</summary> <figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="c"># primeiro deve-se clonar o projeto `example-backend` localmente.</span>
<span class="nv">$ </span>git clone git@github.com:pFransozi/docker-hy-material-applications.git
<span class="c">#</span>
<span class="c"># acessar o diretório do arquivo fonte</span>
<span class="nv">$ </span><span class="nb">cd </span>example-backend
<span class="c">#</span>
<span class="c"># criar arquivo `dockerfile`.</span>
<span class="nv">$ </span><span class="nb">touch </span>ex-backend-dockerfile
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"FROM golang "</span> <span class="o">&gt;</span> ex-backend-dockerfile
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"COPY . /go/src/ "</span> <span class="o">&gt;&gt;</span> ex-backend-dockerfile
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"WORKDIR /go/src/ "</span> <span class="o">&gt;&gt;</span> ex-backend-dockerfile
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"RUN go build "</span> <span class="o">&gt;&gt;</span> ex-backend-dockerfile
<span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"RUN go test "</span> <span class="o">&gt;&gt;</span> ex-backend-dockerfile
<span class="c">#</span>
<span class="c">#</span>
<span class="nv">$ </span>docker build <span class="nt">-t</span> go-app:v1 <span class="nt">-f</span> ./ex-backend-dockerfile <span class="nb">.</span>
<span class="nv">$ </span>docker run <span class="nt">-it</span> <span class="nt">-p8083</span>:8080 go-app:v1 ./server</code></pre></figure> </details> <p><br></p> <p><a href="#introdu%C3%A7%C3%A3o">⇡</a></p> <h2 id="referências">Referências</h2> <p><a href="hub.docker.com" target="_blank">hub.docker.com</a>.</p> <p><a href="docs.docker.com" target="_blank">docs.docker.com</a>.</p> <p><a href="https://docs.docker.com/docker-hub/official_images/" target="_blank" rel="external nofollow noopener">docs.docker.com: docker-hub official_images</a>.</p> <p><a href="https://docs.docker.com/engine/reference/commandline/cli/" target="_blank" rel="external nofollow noopener">docs.docker.com: commandline cli</a>.</p> <p><a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="external nofollow noopener">docs.docker.com: reference builder</a>.</p> <p><a href="https://training.play-with-docker.com/" target="_blank" rel="external nofollow noopener">training.play-with-docker.com</a>.</p> <p><a href="https://github.com/docker-library" target="_blank" rel="external nofollow noopener">github.com: docker-library</a>.</p> <p><a href="https://github.com/docker-library/official-images" target="_blank" rel="external nofollow noopener">github.com: official-images</a>.</p> <p><a href="https://github.com/wagoodman/dive" target="_blank" rel="external nofollow noopener">github.com: wagoodman dive</a>.</p> <p><a href="https://en.wikipedia.org/wiki/Docker_(software)" target="_blank" rel="external nofollow noopener">en.wikipedia.org: docker</a>.</p> <p><a href="https://www.mooc.fi/en/" target="_blank" rel="external nofollow noopener">mooc.fi</a>.</p> <p><a href="https://devopswithdocker.com/" target="_blank" rel="external nofollow noopener">devopswithdocker</a>.</p> <p><a href="https://github.com/docker-hy" target="_blank" rel="external nofollow noopener">github.com: docker-hy</a>.</p> <p><a href="https://www.tutorialworks.com/why-containers-stop/" target="_blank" rel="external nofollow noopener">why-containers-stop</a>.</p> <p><a href="https://www.baeldung.com/linux/docker-run-interactive-tty-options" target="_blank" rel="external nofollow noopener">docker-run-interactive-tty-options</a>.</p> <p><a href="https://www.baeldung.com/ops/dockerfile-env-variable" target="_blank" rel="external nofollow noopener">dockerfile-env-variable</a>.</p> <p><a href="https://serverfault.com/questions/897847/what-does-the-input-device-is-not-a-tty-exactly-mean-in-docker-run-output" target="_blank" rel="external nofollow noopener">what-does-the-input-device-is-not-a-tty-exactly-mean-in-docker-run-output</a>.</p> <p><a href="https://quay.io/" target="_blank" rel="external nofollow noopener">quay.io</a>.</p> <p><a href="https://stackoverflow.com/questions/71853912/docker-workdir-create-a-layer" target="_blank" rel="external nofollow noopener">docker-workdir-create-a-layer</a>.</p> <p><a href="https://blog.hipolabs.com/understanding-docker-without-losing-your-shit-cf2b30307c63" target="_blank" rel="external nofollow noopener">understanding-docker-without-losing-your-shit-cf2b30307c63</a>.</p> <p><a href="https://dev.to/aws-builders/understanding-the-dockerfile-format-3cc6" target="_blank" rel="external nofollow noopener">understanding-the-dockerfile-format-3cc6</a>.</p> <p><a href="#introdu%C3%A7%C3%A3o">⇡</a></p> </article> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2023 Philipe Fransozi. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Last updated: June 25, 2023. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="/assets/js/common.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>